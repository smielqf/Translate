\documentclass{book}
\usepackage{xeCJK}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}

% 结合\quad可以是现在每个章节首行空两格
\setlength{\parindent}{2em}

\begin{document}
\title{Systems and Software Verification中文翻译版本}
\author{林奇峰}
\date{\today}
\maketitle
\tableofcontents
    \chapter{Automata 自动机}

    正如前言所述，模型检查包括验证系统模型的一些属性。在任何检查开始之前，一个人就必须面对正在研究的系统的建模任务。坦白地说，我们强调这个建模步骤是困难的，但又对后续获得的结果的相关性至关重要。没有通用的方法来建模一个系统:建模是一项具有挑战性的任务，最后交付给一些能够很好结合物理现实和应用现实或者计算机模型的资深工程师来执行。此外，在建模前引入建模专家和“区域”专家的混合团队的做法是可取的。

    这一章并不是说能提供一种极其简单的建模方法(不然，不夸张地说是这是过于雄心勃勃的目标)。相反地，我们会谦虚地为大多数模型检查方法提供一种通用基础模型来破除迷惑或者其他阻碍。在本章中使用玩具示例，我们将说明这个通用模型是如何用来表示对象或“真实的”系统的。

    \section{引导例子(Intoductory Examples)}

    最适合用模型检查技术来验证的系统是那些容易被(有限)自动机们建模的系统。简单地说，自动机是一种利用转换(transition)操作来从一个状态(state)迁移到另外一个状态的机器。例如，一个数字手表可以用一个自动机来表示。当中，每个状态代表了当前的小时和分钟(我们忽略了秒)。因此有24 x 60 = 1440个可能的状态。而且任意一个状态对有一条转换链。状态保存了一分钟过去的当前时间
    \begin{figure}
    \centering
    \includegraphics[height=0.6in,width=4.0in]{1_1.jpg}
    \caption{A model of watch}
    \end{figure}

    自动机(或自动机的一部分)的图形化表示通常为：每个状态都是一个圆圈，每个转换都是一个箭头(见Figure 1.1)。一个没有来源的传入箭头标识初始状态。

    图形化表示的可用性是基于自动机的形式主义的优点之一。这些表示为我们理解系统操作提供了宝贵的支持。

    另一个例子(一个可以完整表示的例子，见Figure 1.2)是一个模3计数器。该自动机表示为$A_{c3}$(上面的数字表可以被看作是某种形式的1440计数器)。$A_{c3}$的状态对应于可能的计数器值。它的转换反映了在计数器上可能的操作。在这个示例中，我们将操作限制为增量(inc)和减量(dec)。
    \begin{figure}
    \centering
    \includegraphics[height=2.0in,width=3.0in]{1_2.jpg}
    \caption{$A_{c3}$: A modulo 3 counter}
    \end{figure}


    同样的道理，一个整数变量可以建模成一个拥有无限多个状态(每个可能值对应一个)的自动机。它允许每个基本操作（肯定是递增/递减1，但也可能是一个符号更改或平方)对应一个转换。虽然存在着对拥有无限多个状态的受限自动机的模型检查技术，但这种技术在本书中只会间接提到。因此，我们从这里假设，除非我们特别提到，否则一个自动机的状态和转换是有限的。

    现在再来考虑一个稍微复杂一点的例子，例如那些控制办公室或建筑大门开/关的数码密码  （digicode）。门在键入正确的字符序列后打开，(在这个简单的数码模型中)无关于任何可能的错误初始尝试。简单起见，我们假设有3个可用的键：A, B, C，而且每当ABA被键入时，门就会打开。由此产生的数码密码可以建模成Figure 1.3所示的拥有4 种 状态和9种转换的自动机。注意图中的单个箭头有时怎样表示两个转换具有相同的起点和相同的终点(例如从3到1，或者从1到1，其中一个标记为B，另一个标记为C）。

    数码密码示例将用于说明两个基本概念，即系统模型的执行（execution）和执行树(execution tree)。执行是描述系统可能演进的状态序列。因此，第1121、12234和112312234是数码密码的执行。在某些情况下，它有利于拼出从一个状态到另一个状态的转变。因为执行1121时，从1到1的时候我们不能告知哪个键被输入【注：从1到1有B，C两种键入方式，而在1→1这个结果上不能看出哪个键被按下】。虽然我们很少会需要这些额外的信息。事实上这没有增加概念上的困难且被大多数模型检查工作所排除在外。

    我们还将关心系统的所有可能的执行。描述此集合的一种方法是按某些顺序“排列”执行(例如按照长度增加的顺序)。接着，数码密码就会表现为

    1

    11,12

    111,112,121,122,123

    1111,1112,1121,1122,1123,1211,1212,1221,1222,1223,1231,1234
    \begin{figure}
    \centering
    \includegraphics[height=2.0in,width=3.0in]{1_3.jpg}
    \caption{A model of a digicode}
    \end{figure}

    出于厘清的原因，我们更倾向于以树的形式组织执行集合。在计算机科学中，树的根在顶部。在这里，根是初始状态1。它的子节点(我们说的直接继承者)，是在一个步骤结束后可以到达的所有状态，在我们的例子中就是1和2。我们重新开始，第1和第2节刚刚创建，分别有两个孩子分别为1和2，三个孩子分别为1、2和3。我们最终获得了一组系统执行的表示(通常是无限的)(见Figure1.4)。

    由于我们的目标是验证系统属性，或者更准确地说，为了验证系统模型的属性，我们将许多我们已知满足的基本属性与每个自动机状态关联起来。举个例子，“门是开的”的属性；存在于状态4而不存在于状态1，2，3。在我们的数码密码例子中，我们的主要兴趣是以下知识:

    1 .如果门打开了(如果执行到达状态4)，那么A,B,A是最后三个按照顺序键入的字母。

    2。键入任意以ABA结尾字母序列就打开了门(也就是说，定义了通向状态4的执行)。

    建模过程中的一个关键步骤是自动机的构建。它表示了当下考虑的系统并在其中我们可以将每个状态与一些我们已知真假的基本属性关联起来。我们随后必须学会用这些基本属性和我们希望系统满足的更复杂的属性来表达自动机。用基本属性表示“复杂”属性的方法取决于我们使用的逻辑（logic）。下一章的目标正是定义这些逻辑。为了将基本性质与更复杂的性质区分开来，在提到基本性质时，我们说成(原子)命题在给定的状态中是真或假。
    \begin{figure}
    \centering
    \includegraphics[height=3.0in,width=4.0in]{1_4.jpg}
    \caption{The begining of the execution tree of the digicode}
    \end{figure}

    这里我们只是简单地画出直观的想法。在我们接下来的示例中，我们可能会被引导来定义这些基本属性：
    $P_A$：刚键入A

    $P_B$：刚键入B

    $P_C$：刚键入C

    $P_A$属性存在于状态2和4，$P_B$单独存在于状态3(实际上不存在于状态1，因为按下C也可以达到)，而$P_C$则不存在于任何状态。

    我们还可以定义以下属性:

    $pred_2$:执行的前一个状态为2;

    $pred_3$:执行的前一个状态是3。


    因此，$pred_2$只在状态3中保持，而$pred_3$仅在状态4中保持。现在考虑一个导致门打开的执行，即结束于状态4的执行。由于$pred_3$在状态4中保持，因此这个执行必须以序列3 4结束。但$pred_2$在状态3中保持，因此实际上执行以序列2 3 4结束。由于$P_A$存在于状态2和4，而$P_B$存在于状态3中，我们得出结论，最后三个字母键入的是A,B,A的顺序。
    因此，我们已经“证明”了两个必要的属性之一:如果门打开了，那么“正确”的字母顺序就会被键入。另一个属性以类似的方式从基本属性中获得。
    准确地来说，模型检查包含了类似这样能够使其自动运行地去验证的技术。

    \section{一些定义(A Few Definitions)}

    我们现在将简要定义上面介绍的概念。我们所称的自动机源自于语言理论的有限自动机，以及在其他领域所使用的Kripke结构（{\itshape kripke structure}）和转换系统({\itshape transition systems})的概念。

    {\itshape  Automata}（自动机）。给定一个基本命题的集合$Prop$= \{P1，…\}，一个自动机可以表示为一个元组$\mathcal{A}=<Q, E, T, q_0, l>$

    •$Q$是状态的有限集;

    •$E$是转换标签的有限;

    •$T \subseteq Q$x$E$x$Q$的转换集合;

    •$q_0$是自动机的初始状态;

    •$l$将$Q$中的每个状态映射成该状态拥有的基本属性有限集。

    如果我们将注意力集中在Figure 1.3上的四个可见状态，那么数码密码的建模对应于以下正式的自动机定义:
    \begin{equation*}
        l=
        \begin{cases}
            1, & \mapsto{\emptyset}\\
            2, & \mapsto{P_A}\\
            3, & \mapsto{P_B,pred_2}\\
            4, & \mapsto{P_A,pred3}.
        \end{cases}
    \end{equation*}
    \begin{tabbing}
        \= $Q=\{1,2,3,4\};$ \quad   \= $T=\{(1,A,2),(1,B,1),(1,C,1),$ \\
        \> $E=\{A.B,C\}$      \> $(2,A,2),(2,B,3),(2,C,1),$\\
        \> $q_0=1$            \> $(3,A,4),(3,B,1),(3,C,1)\}$\\
    \end{tabbing}


    Graphical representation（图形化表示）。请注意，Figure 1.3并没有完全包含元组$<Q,E,T,q_0,l>$中可用的信息。实际上，为了保持原始图的简单性，没有描述出状态中原子命题的标记。我们今后将经常用出现在状态中的原子命题来表示和验证自动机。有时候由于缺少空
    间，我们会省略一些命题，或者一些状态名称。Figure1.5为数码密码示例的完整表示。类似地，我们偶尔会省略，甚至不考虑转换标签。例如当像在电子表示例中(figure1.1)这些不相关的时候。
    \begin{figure}
    \centering
    \includegraphics[height=1.5in,width=3.0in]{1_5.jpg}
    \caption{The doigicode with its atomic propositions}
    \end{figure}

    行为的正式定义（Formal defination of behavior）。自动机的路径是一个简单的，有限或者有限长的转换序列${\sigma}$。序列中的转变如$q'=q_i+1$一样一个接着一个：比如
    \begin{equation*}
    3\xrightarrow{B} 1\xrightarrow{A} 2\xrightarrow{A} 2
    \end{equation*}是一个digicode路径(见Figure 1.5)。
    $\sigma$的路径的长度,表示$|\sigma|$,是其潜在的转换的无限数量:$\sigma\in N \cup\{\omega\}$(其中N表示自然数的集合和$\omega$表示无穷)。第i个$\sigma$,写作$\sigma(i)$,是状态$q_i$经过i次转换后的结果。后者只有i<|$\omega$|才有定义。
    偏置执行(partial execution)是从初始状态$q_0$开始的一条路径。例如
    \begin{equation*}
    1\xrightarrow{A} 2\xrightarrow{A} 2\xrightarrow{B} 3
    \end{equation*}

是数码密码的部分执行代码。

    完全执行(complete execution)是一个最大的执行，即不能被扩展的执行。因此，它要么是无限的，要么结束于一个没有其他转变方式能够考虑的状态$q_n$，(在这种情况下，我们可以说成死锁)。

    当我们谈到没有限定符的执行时，我们通常指的是一个完全执行。我们偶尔会改变初始状态;我们可以通过引用“执行……””来表示。

    完全执行是自动机的真实行为;这些与活跃度的假设有关。根据这一假设，自动机总是最终完成到另一个状态的过渡。(注意我们的建模示例，从电子表开始，都经常依赖于这个假设)。

    执行树的正式的定义过于繁琐和冗长，而且不会对我们的讨论有所贡献。因此，我们只需满足于我们对这一概念的非正式处理，如上面的digicode例子。

    为了给这些定义一个结论，我们引入可到达状态(reachable state)的概念。如果一个状态出现在自动机的执行树中，或者换句话说，如果它存在于至少一种执行中，则该状态是可到达的。到目前为止，我们考虑的所有自动机的所有状态都是可到达的。我们稍后会看到，情况并非总是如此。

    \section{打印机管理器(A printer Manager)}
    再来看另一个例子，一台由两个用户共享的打印机。假设这个管理器建模的结果是Figure 1.6所给出的有限自动机。
    \begin{figure}
    \centering
    \includegraphics[height=3.4in,width=4.0in]{1_6.jpg}
    \caption{A printer manager}
    \end{figure}

    显然，最重要的是各种行为或命题的“物理”意义。$req_A$是用户A发出的打印请求，$beg_A$是一条来自打印机，暗示应开始用户A的打印作业的消息。$end_A$是一条来自打印机，暗示用户A的打印作业已经结束的消息。$req_B$，$beg_B$，$end_B$是对应的用户B的步骤。这些原子命题是根据以下实际来确定的：

    $W_A$:源自用户A且尚未被处理的请求(用户A正在等待);

    $W_B$:源自用户B且尚未被处理的请求;

    $P_A$:打印机正在为用户A打印文档;

    $P_B$:打印机正在为用户B打印文档;

    $R_A$:没有正在等待的用户A的请求(用户A在“休息”);

    $R_B$:没有正在等待的用户B的请求。

    正式的定义来说，打印管理器被建模成有限自动机$\mathcal{A}=<Q,E,T,q_0,l>$，其中：
     \begin{tabbing}
      test  \kill
      % \> for next tab, \\ for new line...
      $Q$=\{0,1,2,3,4,5,6,7\}; \\
      $E$={$req_A$,$req_B$,$beg_A$,$beg_B$,$end_A$,$end_B$}; \\
      $q_0$=0; \\
      $T$=\{(0,$req_A$,1),(0,$req_B$,2),(1,$req_B$,3),(1,$beg_A$,6),(2,$req_A$,3),\\
      \quad\quad (2,$beg_B$,7),(3,$beg_A$,5),(3,$beg_B$,4),(4,$end_B$,1),(5,$end_A$,2),\\
      \quad\quad (6,$end_A$,0),(6,$req_B$,5),(7,$end_B$,0),(7,$req_A$,4)\};\\

      \end{tabbing}
    \begin{flushleft}
      \begin{equation*}
        l=
        \begin{cases}
          0, & \{R_A,R_B\} \\
          1, & \{W_A,R_B\} \\
          2, & \{R_A,W_B\} \\
          3, & \{W_A,W_B\} \\
          4, & \{W_A,P_B\} \\
          5, & \{P_A,W_B\} \\
          6, & \{P_A,R_B\}\\
          7, & \{R_A,P_B\}.
        \end{cases}
      \end{equation*}
    \end{flushleft}



    现在打印机管理器已经完全建模好了。我们可以研究它的属性(更准确地来讲，是它的模型的属性)。例如，我们无疑希望证明任何打印操作之前都有一个打印请求。给定以上命题，对于用户A来说，就可以转化为:

1 .在任何执行中，$P_A$存在的任意一个状态都有一个$W_A$存在的状态在其前面。

    同样，我们想要检查任何打印请求最终是否得到满足，对于用户A，翻译成:

2.在任何执行中，$W_A$存在的任意一个状态都有一个$P_A$存在的状态在其后面。
    模型检查技术允许我们自动证明属性1是满意的(这也很容易“手工”完成)。

    这些技术也可以识别一个反例，证明属性2的失败。例如，要考虑执行0 1 3 4 1 3 4 1 3 4 1 3 4 1…(我们省略了标签)。因此，这个印刷管理是不公平的。因为它没有按照请求发出的顺序处理。因此打印管理器可以无限期地延迟打印文档!

    \section{更多变量(A Few more Variables)}
    当建模真实的系统时，让自动机操作状态变量(state variables)通常是很方便的。然后，我们便将控制(control)和数据(data)一份为二：“状态(state)+转变(transition)”构成了自动机的控制，而变量代表数据。

    最常见的情况是，自动机的变量只假设有限的值，要么因为这是被建模的系统的一个特性，或者因为这个限制是故意增加的(例如，为了使模型检查工具的使用成为可能)。即使从理论上的观点来看，只有有限值的变量本身就可以被自动的2所建模。这可以更方便地明确地考虑它们。

    因此，在数码密码的例子中，假设我们必须计算用户的错误数。为此，我们将添加一个初始值为0的整数变量ctr来累积错误的次数。自动机通过两种方式与变量交互:

    赋值(Assignment):转换可以修改一个(或多个)变量的值。因此，在数码密码例子中，错误的转换，也就是说，除了(1,a,2)，(2,B,3)et(3,a,4)之外的所有转换，都会增加计数器。

    守卫(Guard):一个转换可以由变量的条件来保护。这意味着除非变量的条件满足，否则不能发生转换。

    \begin{figure}
    \centering
    \includegraphics[height=3.4in,width=4.0in]{1_7.png}
    \caption{The digicode with guarded transistions}
    \end{figure}
    再次回到数码密码例子中，如果我们希望能够容忍用户的不超过3个错误，那么对应于错误的转换(1、B、1)、(1、C、1)、(2、C、1)等将被ctr < 3的条件所保护。然后，我们通过添加一个警报来完善系统，当检测到四个错误时发出警报。我们创建了一个新的状态err，以及从由条件ctr = 3所保护的1到err，2到err,3到err的3条转换。


    图形化表示（Graphical representation）。Figure 1.7描述了带有变量ctr的数码密码自动机。拥有guard和变量的转换根据一种已建的良好图形化传统来更新：if关键字在guard前面，然后接着转换标签，最后是赋值。为了简化，我们省略了“始终为真”的守卫，它们出现在无条件的转换上，以及没有修改任何变量的空赋值。

    展开(Unfolding)。例如，为了应用模型检查方法，通常需要将拥有变量的自动机的行为展开到一个只有可能的转换出现的状态图中。这样配置就可以很好被标识出来。然后我们保留着这个展开系统的“自动机”术语，即使在文章中经常会用更技术性的术语“转换系统”(transition systems)。 我们将讨论与(自动机)相关的展开自动机。

    展开的自动机的状态被称为全局状态(global states)。它们有许多组件:对应于“小”原始自动机A的状态，和一个给每个变量赋值的组件。我们将使用带有错误计数器的digicode的例子来说明它是如何工作的，而不是给出正式的定义。在展开之后，我们得到Figure 1.8的自动机。
    \begin{figure}
    \centering
    \includegraphics[height=3.4in,width=3.4in]{1_8.png}
    \caption{The digicode with error counting}
    \end{figure}

    注意转换不再被保护。因为我们明确知道每个状态下计数器的值，所以我们知道在没有guards的情况下被保护的转换是否有可能发生(在后一种情况下，根本没有转换)。

    还要注意，在转换过程中没有赋值。由于我们知道每个状态中计数器的值，因此一个转换直接到了新数值的全局状态。

    在全局状态中，例如(1,ctr = 0)，我们说1是控制状态(control state)。实际上，控制状态是在其展开之前自动机的“状态”的组件。控制状态在很大程度上决定了相关的转换，尽管其作用是通过保护变量的当前值来实现的。

    \section{同步积(Synchronization Product)}
    上面的讨论显示了怎样用有限自动机为简单对象(计数器、digicode、打印机管理器等)建模。当我们处理现实中的程序或系统时，这些通常被分解成模块或子系统。为了构建整个系统的模型，很自然地，首先对系统组件进行建模。然后，通过让组件自动机进行协作来组成全局自动机。

    在自动机之间实现这种协作的方法有很多，即同步。在这里，我们简要介绍了主要方法。注意，用一个自动机来直接表示通常有很多状态的整个系统近乎不可能。我们称其为“状态爆炸”(stat explosion)。标准计算机可用内存能够容纳十亿个状态，而处理一个这样的作业并不罕见。

    一个不需同步的例子(An example without synchronization)。最简单的情况是系统可以被分解成不用相互交互的组件。全局自动机则是代表各个组件的自动机们的笛卡儿积。也就是说，一个(全局)状态实际上是由不同的组件状态(局部状态)组成的向量。

    例如，要建模一个由模2计数器、模3计数器和模4计数器组成的系统，我们将使用前面遇到的自动机$A_{c3}$(见Figure 1.2)，我们将以类似的方式构建automata $A_{c2}$和$A_{c4}$。我们的最终系统将由3个分别有2个、3个和4个状态的自动机组成。
    \begin{figure}
    \centering
    \includegraphics[height=3.4in,width=4.0in]{1_9.png}
    \caption{The states of the product of the three counters}
    \end{figure}
    全局系统自动机，表示为$\mathcal{A}_ccc$，则有2个x 3 x 4 = 24个状态。这些状态展示在Figure 1.9中。我们使用透视图来说明每个状态是如何由三个不同的组件组成的，这些组件实际上是独立的计数器。模2计数器、模3计数器、模4计数器的状态则分别在深度、宽度和高度三个维度上变化。

    我们还没有具体说明这24个状态之间的转换。事实上这些状态是从各自计数器中单独得到的。如果不需要同步，则每个状态中的每个组件(即单独计数器)都可以递减、递增或保持不变。这个结果是3×3×3 = 27个可能的选项。

    注意，对于单个计数器，保持不变在Figure 1.2中的没有对应的转换。这么做是为了说明在不同的计数器之间独立变化的时候计数器会怎样表现：结果是这个计数器什么事都没有做。因为这个原因，我们在27种可能性中选择忽略那些没有计数器变化的。这样在每个状态中仍然有26个可能的转变，因此在全球自动机中有24个x 26 = 624个转换。

    图1.10描述了初始状态0,0,0的一些转换。不用重载图表，我们只包括与一个(或更多)增量相对应的转换，并抑制任何减量的转换。这样，在26种可能性中就剩下2×2 - 2-1 = 7的转换，。从0、0、0到0、1、1被标记为“-，inc，inc”，表示第一个组件不做任何事(表示)，另外两个组件执行一个inc的转换。
    \begin{figure}
    \centering
    \includegraphics[height=3.4in,width=4.0in]{1_10.png}
    \caption{A few transitions of the product of the three product of the three counters}
    \end{figure}

    一个同步的例子({\itshape An example with synchronization})。如果我们现在想要同步三个计数器，会有很多不同的变体(选择哪个当然取决于要建模的问题的性质)。例如，我们将三个计数器绑定并且禁止其单独变化或者保持不变。则只剩下两种转换，表示为"inc, inc, inc"和"dec, dec, dec"会离开每个状态。因此只有一些状态是可达的。

    另一种可能，完全相反，就是将计数器解绑，同时只允许头一次在一个计数器上进行更新。则离开每个状态的转换就会单独更新一个计数器，例如“-，-，inc”以及单个计数器减量的那些。这就得到了具有24×3×2转换。我们可以也想象一个中间状态，前两个计数器同时增加或者后两个计数器同时减少。

    所有这些选项都很容易在一个通用的正式设置中表达为由Arnold和Nivat(AN82,Arn92)引入的自动机的同步积。

    同步积({\itshape Synchronization product})。让我们考虑一个有n个自动机的家族，$\forall{i}\subseteq\{ 1，…n\}$，$ A_i=<Q_i, E_i, T_i, q_0, l_i>$，并引入一个新标签“-”来表示不为任何自动机做事的虚拟动作并在组件集合的全局转换过程中保持不变。
    这些自动机们的笛卡尔积$\mathcal{A}_1$x...x$\mathcal{A}_n$就是自动机$\mathcal{A} =<Q,E,T,q_0,l>$，其中：
    \begin{itemize}
      \item $Q=Q_1$x...x$Q_n$;
      \item $E=\prod_{}{}_{1\leq i \leq n}(E_i\cup\{-\})$;
      \item $T=\left.\{ ((q_1,...,q_n),(q_1',...,q_n')) |  for\right.$ $all$ $i$, $e_i='-'$ and $q_i'=q_i$, or $e_i\neq '-'$ and $(q_i,e_i,q_i')\in T_i \left.\right\} $;
      \item $q_0=(q_{0,1},...,q_{0,n})$;
      \item $l((q_1,...,q_n))=\cup _{1\leq i \leq n}l_i(q_i)$
    \end{itemize}

    因此，在笛卡儿积中，每个组件Ai在一个转换中，要么不做任何事(虚构的动作，1'-')，要么执行“局部”转换。在不同的组件之间没有任何同步要求。此外，笛卡儿积包含所有组件“什么都不做”的转换('-')。

    为了同步组件，我们将限制允许在笛卡儿积中存在的转换。因此，我们定义了一个同步集(synchronization set):
    \begin{equation*}
      Sync \subseteq \prod_{1\leq i \leq n}^{}(E_i\cup\{-\})
    \end{equation*}

    Sync指明了在笛卡儿积中对应于同步(允许)的标签和那些不允许的。

    例如，如果我们希望将3个计数器与我们前面的示例中的3个计数器相结合，我们可以定义为同步集:Sync = {(inc,inc,inc)，(dec,dec,dec)}，并由一个$\mathcal{A}_{ccc}^{coup1}$(Figure 1.11)表示。





    同步积由自动机组件和同步集给出，也就是说，同步积的执行是源自同步集当中的笛卡儿积的执行。因此，同步积在直接积定义中可以用以下定义:

    $T=\left.\{ ((q_1,...,q_n),(e_1,...,e_n)(q_1',...,q_n')) | (e_i,..,e_n)\in Sync \right.$ and $\forall(i)$, $e_i='-'$ and $q_i'=q_i$, or $e_i\neq '-'$ and $(q_i,e_i,q_i')\in T_i \left.\right\} $;

    在这本书中，我们有时候用$\mathcal{A}_1||...||\mathcal{A}_n$这个表示自动机的积。隐藏的同步集必须要指明（或者保持不明）。

    重新标识(Relabelling)。一旦一个复杂的自动机被构造成代表子系统的许多较小的自动机的同步，就习惯在自动机积中替换一些标签。例如，在我们的计数器产品的强耦合版本中，我们倾向于简洁地写成inc而不是冗余的(inc,inc,inc)。

    在其他情况下，动机是不同的。例如，一旦获得了全局积，我们可能不再想要区分用于同步转换的标签和那些无关的。

    在这本书中，我们省略了这种重标识操作的形式(尽管是自然的，但没有信息的)定义。尽管如此，我们还是会自由地使用重新标识。

    可达状态(Reachable states)。判断一个同步积中的某个状态是否可达不是很显性可见。可达性当然很大程度上依赖于伴随的同步约束。例如，在三个计数器的例子中，如果我们迫使三个计数器同时变化，只有12个状态是可到达的。如果我们通过释放第三个计数器来松弛这一同步，所有24个状态将再次变得可达。然而，如果第二个计数器被释放，那么可到达的状态就是那些第一个和第三个组成部分由(0,0)，(1,1)，(0,2)和(1,3)所给出的，这将产生12个可到达的状态。

    Figure 1.11描述了我们三个计数器的强耦合积，只有从初始状态可到达的状态，以及连接这些状态的转换。每个转换都是(三元)递增或(三元)递减。
    \begin{figure}
    \centering
    \includegraphics[height=3.4in,width=4.0in]{1_11.png}
    \caption{The automaton $A_{ccc}^{coup1}$ restricted to reachable states}
    \end{figure}
    \begin{figure}
    \centering
    \includegraphics[height=2.0in,width=4.0in]{1_12.png}
    \caption{The rearranged automaton $A_{ccc}^{coup1}$}
    \end{figure}


    显然，一种更简单的可视化结果的方法需要自动机的空间重新调整：Figure 1.12表明，强耦合积表现为一个模12计数器。不可到达的状态用虚线表示。他们还展示了一个模12计数器的行为。

    接下来，我们将从给定的自动机中删除不可到达的状态得到可达图。这是与给定的自动机中唯一有关的行为描述部分。例如，通过删除图1.12中的虚线绘制的任何东西得到一个$A_{ccc}^{coup1}$的可达图。

    可达状态和验证(reachable state and verification)。当一个系统需要被验证时，我们通常会发现我们感兴趣的属性可以很简单地用可达图来标识出来的(第6章致力于可达性属性)。

    例如，在打印机管理器构建为同步积的情况下，我们要求两个用户同时打印的状态是可达的。

    为了解决这些问题，一个能够构造自动机同步积的可达图的工具将是最有用的。这本书的第三部分描述了这些工具。

    我们之前提到了在同步产品中确定一个状态是否可到达的困难性。这个问题实际上是可组合的。一般来说，正如后面解释的那样，任何方法都将或多或少地构建(或探索)可达图(6.3节)。这个图表的大小可能是庞大的。让自动机为$\mathcal{A}_1，…，\mathcal{A}_p$有$n_1,…,n_p$个状态。他们的同步积涉及到许多按照$n_1$ x $n_2$ x…x $n_p$np顺序增长的状态。这个是一种指数增长。这就是状态爆炸(state explosion)的问题，在第3.3节中再次遇到。

    当一个带有变量的自动机被展开时，如果变量范围无限，那么全局自动机的全球状态数是无穷大的。如果变量有界，这个数字可能是指数增长。

    一个从理论的角度来看很有趣，在实践中很重要的与Petri网有关的特殊案例。Petri网是非常适合表达并行系统的操作模型(例如，感兴趣的阅读器被称为[VC92])。

    在这本书的框架中，可以将Petri网看作是加强版的同步自动机，允许动态创建并行组件，或者通过使用一组受限的原语来处理整数计数器。第14章描述了专门为Petri网量身定制的工具。

    Kosaraju和Mayr[Kos82,May84]的一个著名的结果表明，在Petri网中，即使当可达性设置为无穷大时，一个状态的可达性也可以被确定(我们将感兴趣的读者介绍给非常清晰的[Reu89])。

    \section{利用消息传递来同步(Synchronization Product)}
    同步积的特殊情况出现在消息传递框架中。在转换标签中，我们区分与发送消息m相关的那些!m和与接收此消息相关的人为？m。在同步积中，只有给定的发送与相应的接收同时执行的转换时才允许。

    一部小电梯({\itshape A smallish elevator})。为了说明这些概念，考虑一下三层楼高的电梯。我们将通过分成以下组件来对电梯进行建模:

    舱室：根据当前楼层和电梯控制器的指令上下移动的舱室;

    三扇门：根据控制器的指令打开并关闭三扇门(每层一扇);

    一个控制器：一个控制三扇门和舱室的控制器。

    我们的模型相当粗糙，并没有考虑三楼(即系统之外的世界)的电梯请求。

    我们接着我们的五种自动机。机舱状态(见Figure 1.13)对应于三层楼。机舱接收指令“向上”或“向下”(向上和向下的信息)，并在改变状态时考虑它们。请注意，我们的模型默认接受所有的命令，但实际上只执行那些物理上可能的命令。例如，当机舱在地面(编号为0)时，下降没有效果。

    一扇门的状态(参见Figure 1.14)简单地用O表示“打开”，而C表示“关闭”。在这里，控制器命令总是被接受，即使是无关紧要的。
    \begin{figure}
    \centering
    \includegraphics[height=1.5in,width=3.0in]{1_13.png}
    \caption{The cabin}
    \end{figure}
    \begin{figure}
    \centering
    \includegraphics[height=1.5in,width=3.0in]{1_14.png}
    \caption{The $i_{th}$ door}
    \end{figure}

    控制器将指令(消息)发送到门和舱室(参见Figure 1.15)。一个更完整的模型将显示控制器如何响应来自电梯用户的请求。状态on i(free i)对应于电梯在第i层的情况，门关闭(门打开)。另外两个状态允许将楼层0与楼层2“直接”联系在一起，即不停留在1层。
    \begin{figure}
    \centering
    \includegraphics[height=3.0in,width=3.0in]{1_15.png}
    \caption{The controller}
    \end{figure}

    最后，还要确定保持在五个自动机中的每个自动机的每个状态中的基本命题。通常情况下，我们将每个状态都与一个简单的基本属性相关联，简单地对应为状态名。

    然后将电梯的自动机建模为这五种自动机的同步积。因此，由此产生的自动机的状态将有五个相应的组件，按照顺序，自动机建模成的状态为door  0、door 1、door 2，cabin和controller。同步约束减少了消息发送/接收的同时执行，正式定义为:
    \begin{tabbing}
      Sync  \kill
      % \> for next tab, \\ for new line...
      Sync=$\{(?open_1,-,-,-,!open_1),(?close_1,-,-,-,!close_1),$\\
     $ \quad(?open_2,-,-,-,!open_2),(?close_2,-,-,-,!close_2)$\\
     $ \quad(?open_3,-,-,-,!open_3),(?close_3,-,-,-,!close_3)$\\
      $\quad(-,-,-,?dowm,!down),(-,-,-,?up,!up)$\}
    \end{tabbing}

    在宣布这个电梯运行之前，我们想要检查一些属性，例如“当舱门在不同楼层的时候，指定楼层的门不能打开”($P_1$)，“舱门在打开的时候不能移动”($P_2$)。

    对于door 1来说，上面的属性($P_1$)转化为一个事实，即任何以0作为第一个组件的状态都必须是0作为第四个分量。换句话说，我们必须证明没有存在的可达状态是第一个组件是0和第四个组件1或2。请注意，这些事实上是使用原子命题表达的属性。同样的道理也适用于其他的门。

    表示属性($P_2$)略显微妙。我们必须证明在任何执行中，前三个组件中的一个是0的状态后面不能有一个第四个组件变化的状态。

    模型检查器有能力构建我们的5个自动机的同步积，并自动检查上述属性是否存在。热衷于使用这个电梯的忧心忡忡的读者，可以绕过模型检查器，构建同步的产品，并试图“手工”验证上述属性。

    异步消息({\itshape Asynchronous message})。还有一种交换消息的方式:异步通信。当消息没有立即收时，我们称为异步通信。一般来说，假设发出但尚未接收到的消息仍然存在于一个或多个通信通道中，有时候被称为缓冲区。在那里它们通常以FIFO顺序处理(首先是先出):消息是按它们发出的顺序转发的。

    例如，这个模型非常适合描述通信协议，而同步通信非常适合描述控制/命令系统。

    请注意，痛道通信可以直接用同步通信来理解。它可以包含一个代表通道行为的自动机(或变量)。从$\mathcal{A}$到$\mathcal{A'}$的发送操作，会变成$\mathcal{A}$和通道之间的同步交换，随后是通道与$\mathcal{A'}$之间的同步交换。

    如果通信信道是无界的(它可能包含任意数量的消息等待接收)，那么可达图是无限的。

    如果通道是有界的，可到达图可能具有指数大小(就初始自动机的大小而言)。

    \section{利用共享变量同步{\itshape (Synchronization by Shared variables)}}
    另一种让系统的组件相互通通信的方法是共享一定数量的变量。即使从理论的角度来看，使用一个同步积来标识共享的变量是可能的，但他们的实际兴趣是这样的，我们更倾向于明确地介绍它们。我们之前看到了变量如何“添加”到自动机中。然后，很自然地允许一个(或多个)变量被多个自动机共享。

    再考虑一下两个用户A和B共享打印机的情况。他们与来自1.3节的不公平的打印机管理器的不愉快的经历促使他们决定分享一个变量turn，跟踪谁拥有打印的权利。

    因此，用户A以Figure 1.16的自动机建模。描述用户B行为的自动机当然也是对称的(参见Figure 1.17)。
    \begin{figure}
    \centering
    \includegraphics[height=1in,width=3.0in]{1_16.png}
    \caption{The user A}
    \end{figure}
    \begin{figure}
    \centering
    \includegraphics[height=1in,width=3.0in]{1_17.png}
    \caption{The user B}
    \end{figure}

    描述一个包含用户A和用户B地系统全局自动机是由这两个自动机和共享变量的值组成的。如果turn的初始值是A，那么全局自动机的初始状态将是(x,z,A)。从这个状态出发，唯一可能到达的转化是(x,z,B)，然后(x,t,B)，最后(x,z,A)。如Figure 1.18所示，我们获得了一个全局自动机。
    注意，转化守卫已经消失了，因为我们只考虑了与共享变量的值相一致的转换。
    \begin{figure}
    \centering
    \includegraphics[height=2in,width=3.0in]{1_18.png}
    \caption{A and B resolve conflicts on their own}
    \end{figure}

    给一个带有共享变量的全局自动机下定义当然是可以的。我们不会在这里拼写出这个定义，因为它很自然地把同步积和展开自动机组合起来，而这些概念都已经定义好了。我们只需在打印机用户的示例上演示共享变量构造。

    显然，两个用户实现的简单协议保证了没有形如(y,t，-)的状态是可达的。用户确信他们永远不会同时打印。但是他们的协议禁止用户连续打印两次!
    在第一章中，我们以一个更有意义的互斥协议为例。我们仍在努力为我们的两个用户提供一个具有合适的打印机管理策略的共享打印机。我们提出了一个Peterson[Pet81]提出的简化版的算法。

    这两个用户现在决定共享3个变量:
    ·变量$r_A$(请求“请求”)，当用户希望打印时，将其设置为true。最初rA是假的;
    ·类似地，$r_B$为用户B扮演相应的角色;
    ·再一次用$turn$变量来解决冲突。

    Figure 1.19显示了用户A行为的自动机模型(B是对称的，简单地交换A和B的角色)，就像在电梯的例子中，我们将每个状态与它的名称对应的唯一的基本命题联系在一起。属性“处于状态4”对应于相应用户的文档打印。
    \begin{figure}
    \centering
    \includegraphics[height=2in,width=3.0in]{1_19.png}
    \caption{Peterson's user A}
    \end{figure}

    这个自动机因此由这两个自动机和三个共享变量$r_A$，$r_B$和$turn$建模而成。一个状态是一个按照那个顺序形成的元组。在这个顺序中，它是A的自动机状态，B的自动机状态，$r_A$的值，$r_B$的值，以及$turn$的值。这个自动机有4 x 4 x 2 x 2 = 128个状态。事实上，可到达的国家只有状态个。特别地，我们可以显示(或请一个模型检查器显示)形如(4、4、-、-)的状态是可访问的，以这种方式保证两个用户不能同时打印。

    实际上，由我们的自动机建模的算法具有我们所追求的所有属性。它特别确保任何打印请求最终都实现了。

    为了证明这种性质，我们必须首先用基本命题来表达它。这正是我们将要定义的各种逻辑的目标。


    \chapter{Temporal logic}

    \paragraph{{\itshape 动机}} 让我们回到电梯的例子。假设电梯的需求包含了以下性质：
    \begin{itemize}
      \item 任意的电梯请求最后都要被满足；
      \item 当一个请求没有被满足而一直在等待的时候，电梯永远不会穿越楼层。
    \end{itemize}

    这些性质与系统的{\itshape 动态行为(dynamic behavior)}有关。它们可以用“时间点t”这种概念来形式化。这一定程度上重组了经典力学中的概念（著名的公式$z(t)=-\frac{1}{2}gt^2$从时间上描述了一个自由落体的电梯）或者运动学（更形象地观点，其中不考虑动作的起因）。举个例子，把时间点$t$的cabin位置写成$H(t)$，时间点$t$上的一个等待前往楼层n的请求表示为$app(n,t)$，以及时间点$t$的楼层服务表示为$serv(n,t)$。如此我们就可以把这两个性质翻译为：
    \begin{equation*}
      \begin{aligned}
      & \forall{t},\forall{n}(app(n,t) \Rightarrow \exists{t'})>t:serv(n,t') \\
      & \forall{t},\forall{t'}>t,\forall{n}\begin{bmatrix}
                                             \bigg( app(n,t) \wedge \neq n \wedge \exists{t_{trav}} \\
                                             t \leq t_{trav} \leq t' \wedge H(t_{trav})=n\bigg) \\
                                             \Rightarrow \bigg(\exists{t_{serv}}:t \leq t_{serv} \leq t' \wedge serv(n,t_{serv})\bigg)
                                           \end{bmatrix}
      \end{aligned}
    \end{equation*}

    对理论家来说，上述的公式属于一阶逻辑({\itshape first-order logic})的领域。这些公式消除了英文表达这些性质所带来的歧义干扰（当然我们假设的$H, app,$etc 也是用英文定义的）。例如，“最终一定”写成$\exists{t'}>t$，其中$t'$没有边界（除了禁止等式$t' \neq t!$以外）。同样，我们没有强制说服务时间点$t_serv$等价于楼层穿越时间点$t_{trav}$：前者是实现的责任，后者是行为的假设。

    上述用的庞大概念相当的复杂冗长，一个很明显的缺点。而时序逻辑({\itshape Temporal logic})是一种不同且适合这种情形的形式化方法。

    时序逻辑({\itshape Temporal Logic})一种专为statements(描述)而定的逻辑并用来推理一些包含时间顺序的概念的东西。A.Pnueli在1977那年首次用它来为系统的行为性质下正式的定义。 与上面所写的数学公式相比， 时序逻辑概念更清晰和简单。例如参数$t$完全地消失了。时序逻辑还提供了即用的概念。它的运算符模拟语言结构（副词“总是”、“直到”、动词的时态等等），造成了自然语言描述和时序逻辑形式化非常地接近。最后，时序逻辑提出了一个正式的语义（{\itshape formal semantics}），一种不可缺少的语言规范工具。

    \paragraph{章节安排} 在这一章中，我们会第一次描述时序逻辑的正式语言。然后我们会严格地定义它的语义。接着通过例子的话，可能会很好地体会到具体的性质是怎样表达出来。我们必须从几个可能的变体中选一个特定的形式化方法：为了一般性起见，我们选择了Emerson 和 Halpern[EH86]介绍的$CTL^*$逻辑（{\itshape Computation Tree Logic}）。

    当然，写时序逻辑语句需要一些经验而且阅读其他人写的语句需要更多的经验。这是模型检查技术推广遇到的障碍之一。

    这一章可能对没有$CTL^*$经验的人来说很难阅读，因为说得太短了而不能迎合新手。我们希望这本书的第二部分不仅仅是补充一些知识。第二部分详细地探讨了不同的性质类型特别是怎样把这些和不同的时序公式类型对应起来。众多从不同角度阐述的例子毫无疑问会最后提供自然且熟悉的方式来理解一开始听起来很深奥的语言。

    \section{时序逻辑语言(The Language of Temporal Logic)}

    \quad $CTL^*$逻辑，与其他模型检查工具使用的时序逻辑一样，都是用来正式地描述与系统执行相关的性质。

    \paragraph{1.} 正如我们在第一章见到的，一条执行（{\itshape execution}）是一个状态序列。时序逻辑用原子命题（{\itshape atomic propositions}）来描述状态。这些命题是某个给定的状态中有明确真值的基本描述。例如，我们想想"nice\_weather"、"open"、"in\_phase\_1"、"x+2=y"，这些都是命题。回忆一下，这些命题最终汇总成一个集合，标记为$Prop={P_1,P_2,\dots}$。状态$q$中的命题$P$为真当且仅当$P \in l(q)$。

    Figure 2.1 描绘一个自动机，其中状态用$Prop$中的命题和一些自动机的执行来标记。

    \begin{figure}
        \centering
        \includegraphics[height=2.5in,width=4.0in]{2_1.jpg}
        \caption{Atomic propositions on an automaton and its executions}
    \end{figure}

    \paragraph{2.} 经典的布尔组合器({\itshape boolean combinators})是必需的主要部分。这些包含了常量\textbf{true}和\textbf{false}、否定词$\neg$、和布尔连结词$\wedge$（合取,“和”）、$\vee$（析取，“或”），$\Rightarrow$（逻辑蕴涵）以及$\Leftrightarrow$（双向蕴涵，“当且仅当”）。这些组合器可以构建与各种简单子公式相关的的复杂语句。

    我们把命题和布尔连结词的混合称为命题公式（$propositional formula$）。例如，意思为“如果error则不warm”的语句$\text{error} \Rightarrow \neg \text{warm}$在figure 2.1 中的所有状态中都是一条真命题公式。注意的是我们说$\neg \text{warm}$存在于状态$q_2$是因为$\text{warm} \notin l(q_2)$。

    \paragraph{3.}时序组合器（{\itshape temporal combinator}）允许一个人描述一条执行上的状态序列，而不仅仅是各个状态各做各的操作。

    最简单的组合是$\mathrm{X}$，$\mathrm{F}$，和$\mathrm{G}$。

    当P表示描述当前状态的一个性质时，$\mathrm{X}P$表示下一个状态（{\itshape next state}）（$\mathrm{X}$代表下一个）满足$P$。例如$P \vee \mathrm{X}P$意思是当前状态或者下一个状态（或者两者都）满足P。在figure 2.1的例子中，$\sigma_1, \sigma_2, \sigma_3$中的每条执行都满足$\mathrm{X}\mathrm{X}\text{error} \vee \mathrm{X}\mathrm{X}\mathrm{X} \text{ok}$。

    $\mathrm{F}P$表示有一个未来的状态（{\itshape a future state}）（$\mathrm{F}$代表“未来”）满足P但不指定是哪个状态。$\mathrm{G}P$则表示所有的未来状态（{\itshape all future states}）都满足$P$。这两个组合器可以不那么正式地理解成：$P$迟早有一天会出现（至少一次）以及 $P$一直都在。我们写个例子：
    \begin{equation*}
      \text{alert} \Rightarrow \mathrm{F} \text{halt}
    \end{equation*}

    这个式子的意思是如果我们(现在)处于一个alert的状态，那么我们将会(随后)到一个halt的状态。如果我们希望这条性质永远都是对的，也就是说任何时间（{\itshape at any time}）alert状态都会跟着一个halt状态在后面。我们将其写成：
    \begin{equation*}
      \mathrm{G}(\text{alert} \Rightarrow \mathrm{F} \text{halt})
    \end{equation*}

    在figure 2.1的例子中，warm的每一次出现都会有个non-warm的状态跟在后面。因此$\mathrm{G}(\text{warm} \Rightarrow \mathrm{F} \neg \text{warm})$ 在 $\mathcal{A}$的所有执行中都为真。我们甚至可以加强这条语句为$mathcal{A}$中的所有执行都满足$\mathrm{G}(\text{warm} \Rightarrow \mathrm{X} \neg \text{warm})$ 在 $\mathcal{A}$，也就是说在当前状态的温度为温暖的时候，下一个状态的温度将不会温暖的这个描述永远为真。

    $\mathrm{G}$是$\mathrm{F}$的对偶：无论公式$\phi$是怎样的，如果$\phi$总是可以被满足，那么$\neg\phi$总有一天会被满足的这个说法是不对的。因此$\mathrm{G}\phi$和$\neg \mathrm{F}\neg\phi$是等价的，写成$\mathrm{G}\phi \equiv \neg \mathrm{F}\neg\phi$

    \paragraph{4.} 可以通过随意地级联不同的时序组合器来发挥时序逻辑的能量和威力：举个例子,$\text{alert} \Rightarrow \mathrm{F} \text{halt}$中$\mathrm{F}$在$\mathrm{G}$的范围内。从更简单的公式开始，时序组合器产生了新的公式。该公式的意义派生自它的组件（子公式）的意义。

    $\mathrm{F}$金和$\mathrm{G}$的级联通常被用来表达重复性质。因此$\mathrm{G}\mathrm{F}\phi$，字面上理解成总是会有一个类似$\phi$的状态迟早会出现，也就是说$\phi$在一条执行的过程中会被无数次满足。这种结构很普遍，并用$\overset{\infty}{\mathrm{F}}$（读作无穷多次）作为$\mathrm{G}\mathrm{F}$的简写。对偶表达则为$\overset{\infty}{\mathrm{G}}$，$\mathrm{F}\mathrm{G}$的简写，意思是“从某个时间点以后的所有时间”或者“每个时间点，除了有限个时间点以外”。

    考虑figure 2.1的一条执行，有两种可能的情况：要不访问状态warm无穷多次，要不最终永远保持在状态error里面。因此，所有的执行都满足公式$\overset{\infty}{\mathrm{F}}\text{ warm} \vee \overset{\infty}{\mathrm{G}} \text{ error}$

    \paragraph{5.} $\cup$组合器（代表直到（{\itshape until}）的意思，不要和集合中的并集操作混淆）更加丰富和复杂。$\phi_1 \cup \phi_2$意思是$\phi_1$直到$\phi_2$验证以后才能得以验证。更准确地讲：$\phi_2$迟早有一天会被验证，同时$\phi_1$也被验证了。举个例子$\mathrm{G}(\text{alert} \Rightarrow \mathrm{F} \text{halt})$可以被下述语句完善：从状态alert开始，警报会一直持续直到状态halt最终并且一定到达：
    \begin{equation*}
      \mathrm{G}(\text{alert} \Rightarrow ( \text{alarm}\cup \text{halt}) )
    \end{equation*}

    $\mathrm{F}$组合器是$\cup$的一个特例。$\mathrm{F}\phi$和$\text{true}\cup\phi$是等价的

    还存在有“弱 直到”（{\itshape weak until}），标记为$\mathrm{W}$。语句$\phi_1\mathrm{W}\phi_2$还是表示为“$\phi_1\text{直到}\phi_2”$，但是不要求$\phi_2$一定要出现（而且如果$\phi_2$从来都不会出现，那么$\phi_1$保持为真直到结束）。这也可以被理解为“$\phi_1$但不$\phi_2$”。注意$\mathrm{W}$还是用术语$\cup$来表达：
    \begin{equation*}
      \phi_1\mathrm{W}\phi_2 \equiv (\phi_1\cup\phi_2) \vee \mathrm{G}\phi_1
    \end{equation*}

    在figure 2.1的例子中，以状态$q_0$为起点的所有执行都满足$\text{ok}\mathrm{W}\text{error}$但是有一条从状态$q_0$开始的执行不满足$\text{ok}\cup\text{error}$。
    \begin{figure}
        \centering
        \includegraphics[width=4.0in,height=3.0in]{2_2.jpg}
        \caption{Four ways of combining E and F}
    \end{figure}

    \paragraph{6.} 截至目前介绍的逻辑只能用来描述一条执行的性质，还仍然只是表达行为的树状图（未来可能会更多地从某个给定的状态开始）。特殊量词$\mathrm{A}$和$\mathrm{E}$可以量化执行的集合。这也叫路径量词（{\itshape path quantifiers}）。

    公式$\mathrm{A}\phi$意思是当前状态开始的所有执行（{\itshape all the executions}）满足性质$\phi$。然而$\mathrm{E}\phi$表示为从当前状态开始，存在有一条执行可以满足$\phi$。

    必须不能把$\mathrm{A}$和$\mathrm{G}$混淆：$\mathrm{A}\phi$意思是当前所有的可能的执行都要满足$\phi$，而$\mathrm{G}\phi$意思是$\phi$在一条考量的执行存在于每个时间点。更通俗地讲，$\mathrm{A}$和$\mathrm{E}$在路径上面量化，而$\mathrm{F}$和$\mathrm{G}$在某条给定的路径的时间点上量化。

    $\mathrm{A}$和$\mathrm{E}$组合器以及$\mathrm{G}$和$\mathrm{F}$常常被用作成对的两部分。例如$\mathrm{E}\mathrm{F}P$意思是有可能在某天$P$会出现（在一条适合的执行上面）。$\mathrm{A}\mathrm{F}P$意思是我们在某天一定会有$P$（不管选择哪条执行）。里面隐含了可能和不可避免的差别。$\mathrm{A}\mathrm{G}P$意思是$P$永远为真,然而$\mathrm{E}\mathrm{G}P$意思则是有一条执行上的每个点都有$P$。Figure 2.2介绍了$\mathrm{A}$或$\mathrm{E}$组合器和$\mathrm{G}$或和$\mathrm{F}$这四种可能的组合。

    让我们回到figure 2.1的例子，我们注意到所有从$q_0$离开以后的执行都会遍历$q_1$。现在，从$q_1$开始，有可能一步之后到达一个满足error的状态。因此从$q_0$离开以后的执行都满足$\mathrm{F}\mathrm{E}\mathrm{X}\text{error}$。注意用量词$\mathrm{E}$很重要，因为有一条路径不满足$\mathrm{F}\mathrm{X} \text{error}$。

    “时间分支逻辑”可以自由地在可能的路径上进行量化。

    量词在公式$\mathrm{A}\mathrm{G}\mathrm{F}P$和$\mathrm{A}\mathrm{G}\mathrm{E}\mathrm{F}P$上面的作用差别非常得突出。前者的意思是每一条路径上（$\mathrm{A}$）的每一个时间点（$\mathrm{G}$），我们一定会遇到一个（$\mathrm{F}$）状态满足$P$。因此$P$会被无穷多次满足无论系统实际上采取何种动作，正如等价表达式$\mathrm{A}\overset{\infty}{\mathrm{F}}P$的清晰描述那样。第二个公式$\mathrm{A}\mathrm{G}\mathrm{E}\mathrm{F}P$意思是任意执行的任意时间点都有可能到达$P$，也就是说$P$总是有潜力可达。即使有一条$P$都不会出现的路径，$\mathrm{A}\mathrm{G}\mathrm{E}\mathrm{F}P$也可以被验证。在每条执行上，第二个量词$\mathrm{E}$可以表达可以选择哪条执行来使系统表现出不同的行为。

    在$CTL^*$，$\mathrm{A}$和$\mathrm{E}$是彼此的对偶，被作为通用量词和存在量词。事实上，如果$\mathrm{A}\phi$没有被验证成功，那么就会有一条执行不满足$\phi$也就是满足$\neg \phi$。因此$\mathrm{A}\phi$和$\neg \mathrm{E}\neg\phi$等价。



    \section{时序逻辑的正式语法(The Formal Syntax of Temporal Logic)}

    \quad 上述的概念自然而然地就引出了下述$CTL^*$的正式语法：
    \begin{equation*}
      \begin{split}
         \phi,\psi :: & = P_1|P_2|\dots   \qquad\qquad\qquad (atomic propositions)\\
           & \quad |\neg\phi|\phi \vee \psi|\phi \Rightarrow\psi|\dots \qquad (boolean combinators)\\
           & \quad |\mathrm{X}\phi|\mathrm{F}\phi|\mathrm{G}\phi|\phi \cup \psi|\dots \qquad(temporal combinators)\\
           & \quad |\mathrm{E}\phi|\mathrm{A}\phi \qquad\qquad\qquad\qquad (path quantifiers)
      \end{split}
    \end{equation*}

    这是一种抽象的语法。在实际中，每一种解决时序公式的工具都会允许有括号并且有它自己的运算符优先级。同样地，每一种工具都有原子命题和组合器的特定集合。最重要的是，根据经验，模型检查工具的范围被限制在$CTL^*$的一部分，通常是CTL或者PLTL。

    \section{时序逻辑的语义(The Semantic of Temporal Logic)}

    \paragraph{哪种模型（{\itshape which models}）}时序逻辑的模型叫做{\itshape Kripke structures}。对我们来说，这只是自动机的另外一个用来引起警示的名字：用来标记一个自动机状态的命题在诸如$CTL^*$的基于状态的逻辑中扮演着基础的角色。同时用来标记自动机转换的动作的重要性就不那么大了。

    转换标签在第一章当中有着基础的作用因为他们让我们可以同步几个子系统。在像第2章的本书章节中，我们只关心和时序逻辑相关的而完全忽略掉这些转换标签并重写自动机为$\mathcal{A}=<Q,T,q_0,l>$，其中$T \subseteq Q \text{x} Q$。另外一方面，我们在这里会大量地使用标记$l$来把每一个状态$q \in Q$和$q$中验证过的原子命题关联起来。回忆一下，这个标记过程是自动机建模的一个非常重要的部分：作为一个或者同个建模过程的一部分，自动机的结构和用来标记这些状态的命题是同一时间内设计完成。

    \paragraph{满足性({\itshape Satisfaction})}我们会正式地定义“公式满足于某个给定的情况”的概念。前面章节的讨论和例子显示了，$CTL^*$的公式和给定自动机的某条执行的指定时间点有关。

    我们会写$\mathcal{A}, \sigma, i \models \phi $，其意思是“在执行$\sigma$的时间点$i$处，$\phi$为真”，其中$\sigma$是$\mathcal{A}$的一条不需要从初始状态开始的执行。$\mathcal{A}$这个背景经常隐藏在背后并从我们的书写忽略。我们描述$\phi$在$\sigma$的某个时间点$i$不满足为$\sigma, i\nvDash \phi$。

    通过$\phi$的结构来定义$\sigma, i \models \phi$，也就是说一个复合公式的真值是它的子公式的真值的函数。

    Figure 2.3因此列出了9种定义条例，对应着9种不同的从子公式构建时序公式的方式。（回忆一下$\sigma(i)$代表$\sigma$的第$i$个状态并且$\sigma$的长度为$|\sigma|$）。派生的操作符（$\Rightarrow, \vee, \overset{\infty}{\mathrm{F}}, \mathrm{W},$etc.）可以被推导出来，因此不再明确提及。
    \begin{figure}
        \centering
        \includegraphics[width=4.0in,height=2.5in]{2_3.jpg}
    \caption{Semantics of $CTL^*$}
    \end{figure}

    一些上述提及的条例（为$\mathrm{F},\mathrm{G}$和$\mathrm{A}$准备的）冗余而且可以由其他条款推导出来。

    现在我们准备好了介绍一个派生的概念：“自动机$\mathcal{A}满足\phi$”，标记为$\mathcal{A}\models\phi$，定义为
    \begin{equation}\label{D1}
      \mathcal{A}\models \phi \text{ iff } \sigma,0\models\phi \text{ for every execution } \sigma \text{ of } \mathcal{A}
    \end{equation}

    当我们讨论模型的正确性的时候，这个概念非常得简便。但是它不是用来作为一个模型的（从$q_0$离开以后的）所有执行的正确性集合。因此$\mathcal{A}\nvDash\phi$并不表示$\mathcal{A} \models \neg\phi$（然而$\sigma,i \nvDash \phi$等价于$\sigma,i \models \neg \phi$）。

    \paragraph{时间的自然属性({\itshape nature of time})} 我们承认在figure 2.3的定义有27页遇到的一阶逻辑的冗余复杂天性。和$\mathrm{F}$语句有关的“存在有如$i \leq j \leq |\sigma|$的j$\dots$”语句让人联想到了$\exists{t'}\geq t$。事实上， 在形式为$\sigma, i \models \phi$的语句种，参数$i$记录了$\sigma$中的时间过程。不管怎样，这两个框架之间存在着很重要的差别。$CTL^*$的语义和时间的自然属性有关：时间点是执行上的节点。一阶逻辑让时间的自然属性模糊不清。当我们写$\exists{t'}>t$的时候，$t'$是什么？是同个执行过程还是不同执行过程的后面某个时间？而且回到开头，$t$是什么？如果我们想要用一阶逻辑来形式化这些需求，那么它就需要把这些问题都描述出来，也就是说选择一个时间模型。

    在$CTL^*$中，时间是离散的（{\itshape discrete}），与连续（{\itshape continuous}）和密集（{\itshape dense}）相反。在$CTL^*$中，在$i$和$i+1$之间什么都不存在。时序逻辑让时间参数变得隐秘：任意一个语句都隐性地与当前时间点有关。而且它的组合器选择确定了一次，对于所有可以用的结构也就确定了。用一阶逻辑更能够容易表达的性质确实存在但这只是很少一部分。可以说时序逻辑对于一阶逻辑来说，是一个可以用机器语言编译的高级语言。

    \section{两种时序逻辑 :PLTL和CTL（PLTL and CTL: Two Temporal Logics）}

    PLTL（{\itshape Propositional Linear Temporal Logic}）和CTL（{\itshape Computation Tree Logic}）是两个在模型检查工具中使用最广泛的两种逻辑。他们的起源不同（PLTL追溯到[Pnu81]和CTL到[CE81]），但是它们都被视为是$CTL^*$的一部分。

    - PLTL去除掉了$CTL^*$中的$\mathrm{A}$和$\mathrm{E}$。因此，在一个给定的执行中，PLTL$\phi$不能检查可选的，会从当前开始的每一步都分离的执行。其中可能会有不确定的选择。PLTL只能用来解决执行的集合而不能解决树状组织的执行。接下来我们会说到路径公式（{\itshape path formula}）而且有时候用有点粗暴的术语“线性时间逻辑”来表示这种形式化方法。

    例如，PLTL不能表达在执行的一些时间点上，系统可能会往这边或者那边拓展执行。典型的例子，性质“P总是有潜力可达”，这个我们之前表达为$\mathrm{A}\mathrm{G}\mathrm{E}\mathrm{F}P$，不能在PLTL中表达。

    Figure 2.4描绘了两个PLTL不能区分两个自动机$\mathcal{A}_1$和$\mathcal{A}_2$。
    \begin{figure}
        \centering
        \includegraphics[width=4.0in,height=2.0in]{2_4.jpg}
        \caption{Two automata, indistinguishable for PLTL}
    \end{figure}

    从PLTL角度看，这两个自动机对应了一个且相同的路径集合，形式为:
    \begin{equation*}
      \begin{aligned}
        & \text{从执行1看来:}\{P,Q\}.\{P\}.\{\_\}\dots \\
        & \text{从执行1看来:}\{P,Q\}.\{P\}.\{Q\}\dots
      \end{aligned}
    \end{equation*}
    如果一个PLTL公式$\phi$存在于其中一个的话，它存在与另外一个。注意有一种CTL公式（看下面）可以辨别$\mathcal{A}_1$为真而$\mathcal{A}_2$为假。

    - CTL 是$CTL^*$的一部分并且要求每个时序组合器（$\mathrm{X},\mathrm{F},\cup,$etc.）立刻接在量词$\mathrm{A}$或者$\mathrm{E}$的范围内。因此CTL可用的组合器可以写成$\mathrm{E}\mathrm{X},\mathrm{A}\mathrm{X},\mathrm{E}\_\cup \_,\mathrm{A}\_\cup \_$和他们的派生物：$\mathrm{E}\mathrm{F}$等等。例如，figure 2.2中的四种组合器都是CTL结构。

    CTL的标准就是语法。因此$\mathrm{E}P\cup\mathrm{A}(P_2\cup P_3)$和$\mathrm{E}P\cup\mathrm{E}(P_2\cup P_3)$都是CTL公式，但是$\mathrm{E}P\cup(P_2\cup P_3)$不是因为$P\cup(P_2\cup P_3$中的$\cup$没有在量词的直接范围内。并且$\mathrm{E}P\cup(P_2\cup P_3)$等价于$\mathrm{E}P\mathrm{E}\cup(P_2\cup P_3)$，事实上是一种CTL公式。（注意$\mathrm{E}\overset{\infty}{\mathrm{F}}P$）不是一个CTL公式，因为$\overset{\infty}{\mathrm{F}}$是$\mathrm{G}\mathrm{F}$的缩写。

    总是要量化未来可能性的需要性显著限制了CTL的表达能力。它不可能级联几个时序组合器当要连续地引用“一条执行”的时候。结果是CTL公式是状态公式（{\itshape state formulas}）。它们的真值只取决于当前的状态（而且这个自动机区域通过它来达到），而不取决于当前执行。这个限制有它的好处并将会在第三章看到。

    当考虑状态公式的时候，习惯地写$q\models \phi$来代表$\phi$在状态$q$被满足。

    回到figure 2.4的例子，在CTL中可以区分$\mathcal{A}_1$和$\mathcal{A}_2$，只要一方面表达为$Q \wedge \neg P$，另外一方面表达为$\neg Q \wedge \neg P$。在$\mathcal{A}_1$可以表达得比$\mathcal{A}_2$长，因为$\mathcal{A}_1,q_0 \models \mathrm{A}\mathrm{X}(\mathrm{E}\mathrm{X}Q\wedge\mathrm{E}\mathrm{X}\neg Q)$然而$\mathcal{A}_2,q_0' \nvDash \mathrm{A}\mathrm{X}(\mathrm{E}\mathrm{X}Q\wedge\mathrm{E}\mathrm{X}\neg Q)$。

    同样的思想，CTL允许用$\mathrm{A}\mathrm{G}\mathrm{E}\mathrm{F}P$来表达潜在可达性但不能允许去表达路径上非常丰富的性质。例如CTL不能表达：存在一条路径$P$会被满足无穷多次（在$CTL^*$中为$\mathrm{E}\overset{\infty}{\mathrm{F}}P$）。通常我们定下了一个接近方式，如$\neg\mathrm{A}\mathrm{F}\neg\mathrm{E}\mathrm{F}P$，意思是“我们迟早有天会到达一个P永远都不会发生的状态的这个说法不对”。后者的性质比$\mathrm{E}\overset{\infty}{\mathrm{F}}P$严格上来说要弱：想象一个系统，其中自环可以让我们在可能选择一个$P$只可能一次的计算之前， 保持在初始状态，不论多长只要我们愿意。那么$\mathrm{E}\overset{\infty}{\mathrm{F}}P$就不能够被验证成功。然而，通过永远保持在初始状态，我们总是可以验证$\mathrm{E}\mathrm{F}P$。这个系统因此满足$\neg\mathrm{A}\mathrm{F}\neg\mathrm{E}\mathrm{F}P$但不满足$\mathrm{E}\overset{\infty}{\mathrm{F}}P$。

    \paragraph{选择哪个（{\itshape  which to choose}）}PLTL或者CTL。理论上，当需要表达的时候，CTL和PLTL有它们各自的长处和短处。这就是为什么会有$CTL^*$定义的出现。$CTL^*$在CTL和PLTL之后提出。

    在实际中，我们试图描述一个系统的期望行为时，CTL的缺点要比PLTL尴尬得多。CTL的大部分弱点可以通过使用FCTL（F代表“公平”，CTL的一种允许我们表达如$\mathrm{E}(\overset{\infty}{\mathrm{F}}P\wedge\overset{\infty}{\mathrm{F}}Q)$的公平性质的扩展）克服。

    然而，CTL的缺点都被用CTL进行模型检查比用PLTL进行更有效率的这个事实抵消掉了。（FCTL对于多项式时间内模型检查非常重要）。

    因此正确的选择是在几个因素之中取其折衷。如果我们的目标是要陈述一些性质，那么我们会选择PLTL（或甚至$CTL^*$中有比PLTL更冷门和技术更加复杂的这两个缺点的一个）。如果我们目标是系统的详尽验证，那么CTL中的规范更有可能避免组合爆炸陷阱。如果我们希望为了检测可能的错误而进行即使验证，那么PLTL会是一个好选择。如果我们需要用这个或那个特定的工具，这个工具会强制使用它的时序逻辑语言而不能选择其它的。主流工具要不用CTL（例如SMV），要不用PLTL（例如SPIN）而且我们很伤心地看到FCTL的使用并没有更加得广泛（SMV允许在模型定义中写下公平性约束，而不是在时序公式中）。

    \section{$CTL^*$的表达能力（The Expressivity of $CTL^*$）}

    \quad 在这个快速的介绍后，读者肯定很好奇$CTL^*$是否真的可以表示实际中感兴趣的性质？

    首先注意到，没有一种逻辑可以表达建模决定中没有考虑的事物。在第1章中遇到的自动机不包括随机概念，例如选择一个转换而不是另一个转换的概率。另外，我们自动机永远不会遭遇失败（{\itshape failures}）而且它们之间的转换没有一段时间来保持（{\itshape duration}）。因此，考虑这些自动机的随机性或者时间属性没有任何意义：需要引进其它模型例如第5章中介绍的定时自动机。

    当性质与自动机的执行树有关时，$CTL^*$相当地有表达能力。理论学家已经得到许多理论来揭露问题的基本面。我们来提两个似乎特别感兴趣的话题：
    \begin{itemize}
      \item 任意一个形如“从外部世界看，被研究的自动机$\mathcal{A}$行为像参照自动机$\mathcal{B}$”都可以用CTL表达。具体地讲就是，对于任意的$\mathcal{B}$，一个CTL公式$\phi_{\mathcal{B}}$可以产生“像$\mathcal{B}$”的意思，也就是说，对于每一个$\mathcal{A}$，$\mathcal{A} \models \phi_{\mathcal{B}}$当且仅当$\mathcal{A}$和$\mathcal{B}$从外部来看是不可区分的。[BCG88]
      \item $CTL^*$组合器的表达能力充足。Kamp[Kamp68,GPSS80]的一个理论显示任意一个语义可以用与figure 2.3相似的条例来表达的时序组合器都可以用被定义为基于$\mathrm{X}$和$\cup$的表达式。举个例子，一个组合器$\mathrm{Z}$定义为“$\sigma \models \phi \mathrm{Z} \psi$当前仅当每一对满足$\phi$的状态对我们都可以找到一个满足$\psi$的状态（严格地限制两者之间）”。这可以用$\cup$和$\mathrm{X}$表达成：
          \begin{equation*}
            \phi\mathrm{Z}\psi=\mathrm{G}(\phi \Rightarrow \mathrm{X}(\neg\phi\mathrm{W}(\psi\wedge\neg\phi)))
          \end{equation*}
    \end{itemize}

    从实用的角度来讲，$CTL^*$大多数情况下都足够了。很少会发生一个感兴趣的性质不能被表达。事实上，我们经常面对的问题是性质是可表达的，但不是自然的，正如我们这本书第二部分看到的那样。

    \chapter{Model Checking}

    \quad 在本章中我们会描述用于模型检查的算法的原理。该算法可以找出一个给定的自动机是否满足一个给定的时序公式。

    我们会各自介绍逻辑CTL和PLTL的模型检查问题。这两个问题需要些许不同的回答并且相应的算法也是独立发展的。

    \section{模型检查CTL（Model Checking CTL）}

    \quad CTL的模型检查算法最初是由Queille, Sifakis, Clarke, Emerson和Sistla[QS82, CES86]发展出来的并且随后被进行了改进（看例子[CGL94a]）。

    这个基础算法再验证领域扮演着很重要的角色。这一部分归因于这个算法在每一个组件里面都是线性时间运行（自动机是一方面，CTL公式是另一方面）。这个算法依赖于CTL只能表达状态公式这个客观事实。事实上，CTL的这个特性让我们可以根据哪个状态满足哪个公式来推导而不是去思索哪条执行才是我们真正感兴趣的目标。

    \paragraph{基本原理{\itshape Basic principle}}. CTL模型检查算法的基础部分一个步骤。该步骤\textbf{标记}哪个运行在自动机$\mathcal{A}$上面以及从CTL公式$\phi$开始会标记自动机的每个状态$q$和$\phi$的每个子公式$\psi$，其中$\psi$满足于状态$q$。最后，对于每个状态和每条子公式，\textbf{q.psi}值为\textbf{真（true）}如果$q\models\psi$，反之为\textbf{假（false）}。

    我们用术语“标记”(marking)是为了表示\textbf{q.psi}的值计算过后就被保留了下来。保留这个过程很重要因为\textbf{q.phi}的标记用了从\textbf{q}开始可达的状态\textbf{q'}的值，即\textbf{phi}的子公式\textbf{psi}的值\textbf{q'.psi}。当\textbf{phi}的标记完成了，很容易通过查找$A$的初始状态$q_0$的值\textbf{q0.phi}就可以说出是否$A\models\phi$。这里这就是算法的关键了：

    \lstset{language=C}
    \begin{lstlisting}
    procedure marking(phi)
        case 1: phi = P
            for all q in Q, if P in l(q) then do q.phi := true,
                                            else do q.phi := false.

        case 2: phi = not psi
            do marking(psi);
            for all q in Q, do q.phi := not(q.psi).

        case 3: phi = psi1 /\ psi2
            do marking(psi1); marking(psi2);
            for all q in Q, do q.phi := and(q.psi1, q.psi2).

        case 4: phi = EX psi
            do marking(psi);
            for all q in Q, do q.phi := false; /* initialisation */
            for all (q, q') in T, if q'.psi = true then do q.phi := true.

        case 5: phi = E psi1 U psi2
            do marking(psi1); marking(psi2);
            for all q in Q,
                q.phi := false; q.seenbefore := false; /* initialisation */
            L := {};                        /* L: states to be processed */
            for all q in Q, if q.psi2 = true then do L := L + {q};
            while L nonempty{
                draw q from L;                              /* must mark q */
                q.phi := true;
                for all (q', q) in T{
                    if q'.seen before = false then do { /* q' is a predecessor of q */
                        q.seenbefore := true;
                        if q'.psiq = true then do L := L + {q'};
                    }
                }
            }

            case 6: phi = A psi U psi2
                /* See further*/
    \end{lstlisting}

    我们看看当$\phi$是一个原子命题（case 1）， 一个否定(case 2) 或者一个合取（case 3）的时候标记是多么得简单。上面三种情况中，$\phi$的标记只需要遍历$Q$次——在$O|Q|$时间内——加上$\phi$的子公式标记所花的时间。

    当$\phi$形如$\text{\textbf{EX}}\psi$（case 4）时， 标记所花的时间就是遍历$T$（自动机的转换集合）。因此这个步骤所花时间不超过$O|T|$， 再加上初始化和$\psi$的标记时间。$\text{\textbf{AX}}\psi$这情况就不讨论了：他等价于$\neg\text{\textbf{EX}}\neg\psi$。

    当$\phi$形如$\text{\textbf{E}}\psi_1\cap\psi_2$（case 5）时，从$\psi_1$何$\psi_2$开始标记的$\phi$的标记所花时间等价为计算图的受控可达性的标准算法（转换必须回溯遍历）。我们选择仔细地描述这样的算法是为了说明这一步时怎样可以不重复访问转换$(q,q')\in T$来完成，也因此计算时间在$O(|Q|+|T|)$以内。

    这个标记算法对于$\text{\textbf{A}}\psi_1\text{U}\psi_2$（case 6）来说有点复杂（看下面）。这依赖于一个发现：状态$q$满足$\text{\textbf{A}}\psi_1\text{U}\psi_2$当且仅当——要不(a)$q$满足$\psi_2$， 要不(b.1)$q$满足$\psi_1$，(b.2)$q$至少有一个子状态并且(b.3)它的子状态都满足$\text{\textbf{A}}\psi_1\text{U}\psi_2$。这个标记算法会将每个状态都与一个计数器\textbf{nb}关联。一开始， \textbf{q.nb}设为{\itshape degree(q)}，也就是$q$在自动机的图中的子状态数。然后， 每次$q$的一个子状态被标记为满足$\text{\textbf{A}}\psi_1\text{U}\psi_2$以后，$q$的计数器就减少一次。当最后\text{\textbf{q.nb}}值为0，我们就知道了$q$的所有子状态都满足$\text{\textbf{A}}\psi_1\text{U}\psi_2$。如果$q$满足$\psi_1$， 那我们就知道它满足$\phi$。
     \lstset{language=C}
    \begin{lstlisting}
    case 6: phi = A psi1 U psi2
        do marking(psi1); marking(psi2);
        L := {}                         /* states to be processed */
        for all q in Q,
            q.nb := degree(q); q.phi = false;      /* initialisation */
        for all q in Q, if q.psi2 = true then do L := L + {q};
        while L nonempty{
            draw q from L;                           /* must mark q */
            L := L - {q};
            q.phi := true;
            for all (q',q) in T {        /* q' is a predecessor of q */
                q'.nb := q'.nb -1;                      /* decrement */
                if(q'.nb = 0) and (q'.psi1 = true) and (q'.phi = false)
                    then do L := L + {q'}
            }
        }
    \end{lstlisting}

    验证这个方法的正确性先不说，对于$\text{\textbf{A}}\psi_1\text{U}\psi_2$， 这比其他情况还复杂。终止条件很明显：每个状态只会被加到等待被处理的状态集合\textbf{L}中一次。

    \paragraph{算法的正确性{\itshape Correctness of the algorithm}.}为了帮助阅读这个代码，我们会证明最后的标记情况（$\phi$形如$\text{\textbf{A}}\psi_1\text{U}\psi_2$）的正确性（其他情况要更简单）。对此我们假设子公式$\psi_1$和$\psi_2$的标记是正确的。 一开始，很容易看出如果\textbf{q.phi}曾经在标记中被设为\textbf{true}，那么$q$满足$\phi$。但反过来来看的话就很难。为了搞清楚，我们想象下\textbf{q.phi}在遍历后值为\textbf{false}。那么$q\nvDash\psi_2$是必须的。如果还有$q\nvDash\psi_1$，那么$q\nvDash\phi$并且\textbf{q.phi}的值是正确的。如果$q\models\psi_1$（而且如果$degree(q) \neq 0$），那么\textbf{q.nb}在标记的最后肯定是正的（不然$q$会被插入到\text{L}中）。因此$q$的一个子状态$q_1$，保留有\textbf{q1.phi}的值为\textbf{false}。同样的推论也可以应用到$q_1$上。它不满足$\psi_2$并且如果它满足$\psi_1$，则它有一个子状态$q_2$不满足$\phi$等等。因此我们列出了一条从$q$出发不满足$\psi_1\text{U}\psi_2$的执行。这证明了$q\nvDash\phi$。因此$q$的标记是对的。

    \paragraph{算法的复杂度{\itshape Complexity of the algorithm}}复杂度分析（包括终止证明）很简单：算法的每一步要不和一个节点$q\in Q$的标记有关，要不和$T$的转换$(q',q)$处理有关。因此一旦$\psi_1$和$\psi_2$的标记完成，那么需要来标记$\phi$的时间在$o(|O|+|T|)$以内，也就是$O(|\mathcal{A}|)$。

    最后，任意公式$\phi$的标记在需要$\phi$的子公式的标记之后，接着$\phi$的耗时为$O|\mathcal{A}|$的特定一步。总的标记花费时间为$O(|\mathcal{A}|\text{x}|\phi|)$。

    用来检查"does $\mathcal{A},q_0\models\phi$"的CTL公式$\phi$可以在$O(|\mathcal{A}|\text{x}|\phi|)$内解决。

    \section{模型检查PLTL( Model checking PLTL)}
    \quad PLTL模型检查算法的原理很大程度归因于Lichtenstein, Pnueli, Vardi and Wolper [LP85, VW86]。我们的讨论会避过某些很技术性的细节：因为这些读者会非常清楚。

    在PLTL的情况中，我们不再和状态公式打交道并且不再依赖于标记自动机的状态。PLTL的公式是路经公式（{\itshape path formulas}）（看2.4小节）并且一个有限自动机通常会产生无限条不同的执行。它们自身长度通常是无限的。在这篇文章中，采用的视角会是语言理论。

    思考一下接下来的公式$\phi:\overset{\infty}{\mathrm{F}}P$。一条满足$\phi$的执行$q_0,q_1,q_2\dots$肯定包含了无限多个$P$满足的位置$q_{n1},q_{n2},\dots$。在每一个这些位置之间肯定有任意个（虽然是有限的）状态满足$\neg P$。我们会说这条执行形如$((\neg P)^*.P)^\omega$。

    同样的思想，一条不满足$\phi$的执行肯定从某个位置开始，接下来的状态只会满足$\neg P$。这样的执行说成形如$(P + \neg P)^*.(\neg P)^\omega$。

    这两个我们刚刚用来表达一条执行满足$\phi$的形式的概念是$\omega$正则表达式（$\omega-regular expressions$）。这些拓展了著名的正则表达式（{\itshape regular expression}）概念，一种用来解决无限多个单词的语言的拓展。在$\omega$正则表达式（$\omega-regular expressions$）我们在经典指数“*”（代表任意次但有限次的重复）旁边添加了新的指数“$\omega$”（代表了无限多次重复）。

    \paragraph{基本原理 {\itshape Basic principle}} PLTL模型检查依赖于将每个PLTL公式$\phi$和一个$\omega$正则表达式$\varepsilon_\phi$关联起来。$\varepsilon_\phi$描述了一条满足$\phi$的执行的表达形式。"dose $\mathcal{A}\models\phi$"问题随之变成“are all the executions of $\mathcal{A} of the form described by \varepsilon_\phi$？”（"是否$\mathcal{A}$的所有执行都是$\varepsilon_\phi$描述的形式？"）。

    在实际中， 这个算法不会在正则表达式上进行推导而是在自动机上。给定一个公式$\phi$，一个PLTL模型检查器会构建一个自动机$\mathcal{B}_{\neg\phi}$来描述不满足$\phi$的执行。这个自动机的规模在最差情况下是$O|2^{|\phi|}|$。我们强力地同步（也就是说，这样以来这两个自动机会同时演变，看1.5小节）$\mathcal{A}$和$\mathcal{B}_{\neg\phi}$来获得一个自动机，表示为$\mathcal{A}\otimes\mathcal{B}_{\neg\phi}$，其中唯一存在的行为只有$\mathcal{A}$中被$\mathcal{B}_{\neg\phi}$接受的行为，也就是说$\mathcal{A}$中不满足的$\phi$的执行。

    这个模型检查问题“does $\mathcal{A}\models\phi$”因此也变成了“is the language recognized by $\mathcal{A}$和$\mathcal{B}_{\neg\phi}$ empty”问题（“$\mathcal{A}$和$\mathcal{B}_{\neg\phi}$表达的语句是否为空”）。
    \begin{figure}
        \centering
        \includegraphics[width=4.0IN]{3_1.JPG}
        \caption{$\mathcal{B}_{\neg\phi}$ for $\phi$:$\text{\textbf{G}}(P)\Rightarrow\text{\textbf{X}}\text{\textbf{F}}Q$}
    \end{figure}

    \paragraph{一个简单的例子{\itshape A simple example}} Figure 3.1描绘了一个公式$\phi$对应的自动机$\mathcal{B}_{\neg\phi}$，其中$P$每次出现都要跟着$Q$的出现，在PLTL中写成 $\phi$:$\text{G}(P)\Rightarrow\text{X}\text{F}Q$。因此$\neg\phi$意味着存在有P出现后我们再也遇不到$Q$。$\mathcal{B}_{\neg\phi}$的运转也就随之清晰。这个自动机是不确定的。他可以选择在任何P被验证的时间来从$q_0$移动到$q_1$去猜测$Q$不再出现了。如果它成功地停在$q_1$无限多次并且不阻塞，那么它事实上就看到了一个违反$\phi$的行为。这就是我们通过给$q_1$加上双圆圈来表示。

    \chapter{TODO}

    \chapter{TODO}

    \chapter{可达性 Reachability Properties}
    \textbf{可达性阐述了一些特定的情况一定会到达（出现）}

    实际中的例子：“we can obtain n<0”（R1， 我们可以获得n<0的情况）， “we can enter a critical section”（R2，我们可以进入临界区）

    通常感兴趣的性质都是可达性的否定（negation）： “we cannot have n<0”（R3, 我们不能有n<0的情况），“we cannot reach \textbf{crash} state”（R4, 我们不能达到\text{crash}状态）。

    可达性可以是简单的（simple），如前面的例子所述，或者当一个条件限制了到达目标状态的路径形式的时候，它是有条件的，有约束的（conditional）：“we can enter the critical section without traversing n=0”（R5，我们可以在不判断n=0的情况下进入临界区）。

    可达性可以应用到任意可达的状态。比较一下"we can always return to the initial state"（R6， 我们总是可以回到初始状态）和“we can return to the initial state”（R7，我们可以回到初始状态）。在R6中， “总是”（always）隐含着“starting from any reachable state”（从任意可达的状态开始）。因此（R6）是要比（R7）强的性质：在后者， 当前状态会有回到初始状态的能力但是其随后的状态就没有了。

    \section{时序逻辑中的可达性 Reachability in Temporal Logic}
    当用时序逻辑表达可达性的时候，EF combinator（组合器）自然而然地出现了并且可达性可以定义为$\text{\textbf{E}}\text{\textbf{F}}\phi$。其中$\phi$是不包含时序组合器（temporal combinator）的命题公式（这样的$\phi$在时序逻辑设定中通常被叫做当前时态公式（present tense formula））。回忆一下$\text{\textbf{E}}\text{\textbf{F}}\phi$读作“there exists a path from the current state along which some state satisfies $\phi$”（存在有一条从当前状态开始的路径，其中的一些状态会满足$\phi$）（看2.1小节）。上面的例子就正式地表达为$\text{\textbf{E}}\text{\textbf{F}}(n<0)$（R1），$\text{\textbf{E}} \text{\textbf{F}} \text{\textbf{crit\_sec}}$，（R2），
    $\neg\text{\textbf{E}}\text{\textbf{F}}(n<0)$（R3），$\neg\text{\textbf{E}}\text{\textbf{F}}\text{\textbf{crash}}$（R4）。回忆一下，$\neg\text{\textbf{E}}\text{\textbf{F}}\phi$的对偶表达为$\text{\textbf{A}}\text{\textbf{G}}\neg\phi$（读作“along very path, at any time, $\neg\phi$”, "无论哪个路径，哪个时间， 都有$\neg\phi$"）。

    从任意可达的状态开始的可达性需要嵌套$\text{\textbf{A}}\text{\textbf{G}}$和$\text{\textbf{E}}\text{\textbf{F}}$：（R6）可以表达为$\text{\textbf{A}}\text{\textbf{G}}($\text{\textbf{E}}\text{\textbf{F }}$\text{\textbf{init}})$。

    条件可达性自然地用$\text{\textbf{A}}\_\text{\textbf{U}}\_$构建，其中$\text{\textbf{U}}$（until）替代了$\text{\textbf{F}}$。（R5）写成$\text{\textbf{E}}(\neq 0)\text{\textbf{U}}\text{\textbf{crit\_sec}}$，读作“存在有一条的路径，$n\neq 0$一直为真直到$\text{\textbf{crit\_sec}}$为真”。

    前面所有的例子都用了CTL逻辑。我们注意到线性时序逻辑PLTL不适合可达性。正如它隐形地量化了所有的路径，PLTL只能表述可达性的反面：某些情况是不可达的。嵌套可达性（Nested reachability）在PLTL中不可表达。

    \section{模型检查器和可达性 Model Checkers and Reachability}
    可达性通常是最容易验证的。

    当一个模型检查工具可以构建一个系统的可达性图的时候，理论上它通过简单地检查这张图就可以回答所有的可达性问题，即使它并没有包含时序逻辑。

    这本书第三部分描述的所有工具可以用这个或者那个的形式回答可达性问题， 而我们认为这样的能力可以构建任意模型检查器的最基本功能性。

    但是这些功能性有很多种：一些工具可以允许一个人约束执行（条件可达性），或者任意选择一个开始状态集合（嵌套可达性），或者验证一个状态家族的可达性（例如“all the states in which $n=0$”，所有$n=0$的状态）。

    一些工具，例如DESIGN/CPN（看14章）,是特地为可达性的验证设计的，并且它们提供了许多参数来帮助用户避免状态爆炸的问题（state explosion problem）。例如DESIGN/CPN会允许用户显性指定图的某些部分弃掉来构建部分状态图。

    \section{可达性图的计算 Computation of the Reachability Graph}
    可达状态的集合通常来说不能立刻地看一眼系统就能得出来。当几个自动机同步（或者使用了变量，定时器，计数器等等的时候），可达状态的集合的构建就变得non-trivial（非平凡）。

    有两种算法家族来解决可达性问题：“forward chaining”（前向链式算法）和“backward chaining”（反向链式算法）。

    \paragraph{Forward chaining（前向链式算法）。} 这个是一种自然而然萌生出的方法：为了构建可达状态的集合，我们从初始状态开始，把它们的子状态添加进去，然后再往下继续直到饱和，即没有新的状态可以添加到集合了。这种计算直接子状态的方法依赖于何种自动机，但是它一般来说很简单，而这是仿真工作的任务。

    唯一的难点是可用性：构建的状态集合可能会有潜在的爆炸问题

    \paragraph{Backward chaining（反向链式算法）。} 这里的想法是构建一个状态集合，从该集合里面的状态开始可以遍历到一些目标状态，其中目标状态是我们想要知道是否可达的状态：我们从这些目标状态开始，添加它们的直接父状态到集合里面，继续这个步骤直到饱和。然后我们测试是否一些初始状态在这个饱和了的状态集合里面。这个步骤只不过4.1小节的$Pre^*(S)$算法的枚举版本。

    前向搜索和反向搜索相比有两个缺点。第一，在前向搜开始之前需要先确定一个目标状态集合：一个人不能实现构建一个可达性图然后检验是否这个或者那个状态出现了。注意一下，虽然如此，这个障碍还有正面效应：目标状态是控制验证的过程只是作为一个额外的参数。

    第二，通常来说，计算直接父状态要比计算子状态复杂得多。当然这个情况也要是视模型而定：例如，在自动机有变量和守卫转换和复杂的赋值情况下，直接子状态要更加容易获得（它可以直接计算表达式的结果），相比之下，直接父状态不容易（这些需要解决等式和找出哪个变量的值会生成合适的表达式结果）。

    最后，这两种方法是互补的。为了找出哪个集合S是可达的，在第一种方法种可以计算出可达性集合然后检验它是否和S有交集，或者可以计算出$Pre^*(S)$再验证是否和初始状态集合有交集。

    通常会发生一种情况：其中一个方法终止得很快而另外一个受累与状态爆炸得问题会延迟。这种情况很难解，因为经常不能预测哪种方法更有可能成功。为了说清楚为什么，想象一个不可达得目标状态集合$S$。在这个情况下，两种算法遇到得集合完全和另外一个不一样，并且其中一个集合的大小并不能提供另外一个集合大小的线索。

    \paragraph{"On-the-fly" exploration。}为了回答可达性问题，“on-the-fly”方法会在不完全构建可达性图的情况下求解。。这个方法的目标还是构建这个图，但是这个构建过程只是随着求解过程部分地构建，并且也不需要记忆之前访问过的东西。这个方法试图摆脱当前计算机相比受限于处理速度，更受限于内存资源的事实。

    从实际的观点来讲，读者应该记住以下内容：on-the-fly 方法在目标状态可达的时候更有效率（答案“yes”不需要详尽的求解才能获得）；它们可以用前向或者反向的方法，虽然它们已经应用了两者中的前一个方法；最后，它们可能可以应用到一些无限状态的系统。

    \chapter{Safety Properties 安全属性}
    一个安全属性表达为：在某些条件下，有一个事件永远不会发生。

    例子到处都是，通常都没有条件限制：“所有的进程永远都不会同时出现在它们的临界区”（S1），或者“内存溢出永远不会发生”（S2），或者“这种情况...是不可能的”（S3）。一个有条件限制的安全性例子为，“只要 钥匙不在点火装置上，汽车就不会启动”（S4）。

    通常来说，从这些例子中可以看到，安全性的描述表达为某种不希望看到的事件不会发生。

    同样地，这些例子显示了可达性的否定就是安全属性（比较一下（A3）和（S3）），安全属性的否定就是可达性。

    \section{Safety Properties in Temporal Logic 时序逻辑中的安全性}
    CTL中的组合器$\text{\textbf{AG}}$和PLTL中的组合器$\text{\textbf{G}}$很自然地表达了安全属性。

    例如，在CTL中，我们可以表述（S1）和（S2）为$\text{\textbf{AG}}\neg(\text{\textbf{crit\_sec}}\wedge\text{\textbf{crit\_sec}})$
    和$\text{\textbf{AG}}\neg\text{\textbf{overflow}}$。对应的PLTL公式（也就分别是$\text{\textbf{G}}\neg(\text{\textbf{crit\_sec}}\wedge\text{\textbf{crit\_sec}})$）
    和$\text{\textbf{G}}\neg\text{\textbf{overflow}}$）是相等的。

    许多安全性都有条件限制，例如“只要 钥匙不在点火装置上，汽车就不会启动”（S4）自然地就用$\text{\textbf{W}}$（weak until）组合器表示。（S4）就正式地表示为：
    \begin{equation}\label{}
      \text{\textbf{A}}\neg\text{\textbf{starts W key}}
    \end{equation}
    读作“不管（\textbf{A}）怎么样，汽车永远不会启动（$\neg$\textbf{starts}）除非（\textbf{W}）钥匙插到了点火装置（key）”。在PLTL中，\textbf{starts W key}是（7.1）式子的等价翻译。

    用strong until表达的式子
    \begin{equation}\label{}
      \text{\textbf{A}}\neg\text{\textbf{starts U key}}
    \end{equation}
    不是很对应（S4）。（7.1）和（7.2）的差别是\textbf{U}和\textbf{W}的差别：strong until需要我们以有一天钥匙的出现结束。所以，在我们8.1小节解释的一样，（7.2）不是一个安全属性。

    \section{A Formal Definition 正式定义}
    在第7章开头的安全属性的定义是不正式且有歧义的。强调安全属性这个概念的重要性是因为我们提供了一个更加精确的定义。

    按照常识来给出这样的定义相当地复杂。命题可以在著作中找到[LS85, ADS86, AS87, Kin94]。这些都引出了一个不正式的想法：我们做的事情越少，我们越有机会找到一个被验证的安全属性。换句话说，满足所有的安全属性的唯一方法就是按兵不动！因此有了一个安全属性的“拓扑”概念：安全属性是任意满足以下条件的属性P：其中若行为C满足P，那么任意 reduced behavior $C'\sqsubseteq C$满足P。当然，我们要给出什么是另外一个行为的reduced behavior的正式定义。例如，对于执行集合$C$和$C'$，我们可以定义$C'\sqsubseteq C$若“$C'$中的每条执行都是$C$中的一条执行的前缀”。另外一个可能性由执行树间的“仿真”概念提供[Mil89]。

    \paragraph{Syntactic characterization 句法特征} 在用时序逻辑表达的某种案例P中，我们可以给出句法特征[Sis85, MP90, CMP92，, Sis94]。一个简洁的表述为：任意一个安全属性都可以写成形如$\text{\textbf{AG}}\phi^-$，其中$\phi^-$是过去时序公式（past temporal formula），即只用到了过去组合器（past combinators）（看下面）和常用的 布尔组合器（boolean combinators）以及原子命题。PLTL的公式$\text{\textbf{G}}\phi^-$是等价的。

    特征暗含的原则如下：当一个安全属性被违背的时候，应该可以立刻检测出来。如果这个依赖于行为的后续，那么一个会立刻终止的行为不会违背这个安全属性。因此我们只需要在当前状态去注意它，利用之前出现过的事件（放宽条件来说：这里的过去包括当前）。

    \paragraph{Temporal logic with past 包含过去的时序逻辑} $\text{CTL}^*$逻辑没有提供过去组合器。这个并不能妨碍$\text{CTL}^*$表达安全属性。它只是妨碍了给出一个简洁的安全属性概念的的特征。

    这里先不给出过去组合器的正式定义（可以看[LS95]来知道）。过去组合器可以被描述为未来组合器的镜像。这样一来$\text{\textbf{F}}^{-1}\phi$和$\text{\textbf{X}}^{-1}\phi$意思为$\phi$在过去的某个时间点为真（对应$ \text{\textbf{F}}^{-1}$）或者在当前时间点的前一个状态（对应$\text{\textbf{X}}^{-1}$）。$\text{\textbf{S}}$是until，$\text{\textbf{U}}$的镜像。公式$\phi\text{\textbf{S}}\psi$意思为$\psi$在过去的某个时间点为真，并且从那时起，$\phi$一直为真。

    过去时序逻辑很微妙的一个点是建立在可能行为树（tree of possible behaviors）的公式解释上。因此$\text{\textbf{F}}^{-1}\phi$并不是图中的一个祖状态，而是到达当前状态的执行中的初始部分遇到的状态。这就是我们为什么不用路径组合器$\text{\textbf{A}}$和$\text{\textbf{E}}$搭配过去组合器：当前状态的过去是固定了的，它是从初始状态开始到当前状态的一条路径。

    \paragraph{$\text{\textbf{AG}}\phi^-$ in practice 实际中的$\text{\textbf{AG}}\phi^-$} 互斥可以写成$\text{\textbf{AG}}\neg(sc_1\wedge sc_2)$，事实上是一条安全性公式：没有未来组合器的子公式$\neg(sc_1\wedge sc_2)$是一个隐形的$\phi^-$。

    让我们回到（7.1）属性的例子。它可以被写成形如：
    \begin{equation}\label{}
      \text{\textbf{AG}}(\text{\textbf{starts}}\Rightarrow \text{\textbf{F}}^{-1} \text{ key} )
    \end{equation}
    在$\text{\textbf{AG}}$的范围内只用了过去组合器（这里是$\text{\textbf{F}}^{-1}$）。这个公式读作“永远（$\text{\textbf{AG}}$）为真，如果汽车启动的话，那么（$\Rightarrow$）钥匙之前（$\text{\textbf{F}}^{-1}$）肯定被插入了”。因此它事实上是一个安全属性公式！

    $\text{\textbf{AG}}\phi^-$形式的安全属性特征很清楚地说明了，如果$\psi_1$和$\psi_2$是安全性公式，那么它们的合取$\psi_1\wedge\psi_2$也是一条安全性公式，但是它们的析取$\psi_1\vee\psi_2$通常来说不是。例如$(\text{\textbf{AG}}P)\vee(\text{\textbf{AG}}Q)$等价于no公式$\text{\textbf{AG}}\phi^-$。

    \paragraph{Safety properties and diagnostic 安全属性和诊断} 在$\text{\textbf{AG}}\phi^-$行驶中，特征有利解释模型检查器的诊断形式从而来对不满足的安全属性公式做出回应。

    如果一个属性$\text{\textbf{AG}}\phi^-$没有被满足，那么存在一条从初始状态开始的有限路径会到达不希望的状况。这样的执行前缀是足够用来诊断的。它包含了所有需要观察$\phi^-$不为真的信息：因为$\phi^-$是一条过去公式，不需要知道后续的执行（可能是无限长的）怎样进行。

    因此，即使安全属性没有给出明确的过去形式，$\text{\textbf{AG}}\phi^-$的特征也可以导出一个结果：总是存在一条有限的执行前缀来满足诊断的目的（当这个属性被违背了）。

    \section{Safety Properties in Practice 实际中的安全属性}
    在理想中，一个安全属性可以通过简单地提交到模型检查器中验证。在现实生活中，这样是困难重重的。

    在这个小节，我们讨论几个在验证安全属性的时候遇到的一些实际问题，并且我们把这些问题作为描述一些方法的动机。所谓的abstraction method（抽象方法）依赖于特定的情境并在11章讲述。简单地注意下，abstraction method 是为了解决状态爆炸或者系统规模问题并且abstraction method可以和其它方法一起组合。

    我们从最简单的情况降到最复杂的情况

    \paragraph{A simple case: non-reachability 一个简单的案例：不可达性} 在实际中，许多安全属性都表达为了可达性的否定：“系统不能进入一个...状态”。

    因此我们就面临着 $\neg\text{\textbf{EF}}(\dots)$，即$\text{\textbf{AG}}\phi^-$，其中$\phi^-$是一个局部属性。例如，$\neg(\text{\textbf{crit\_in}} _2\wedge\text{\textbf{crit\_in}}_2)$是一个没有过去或者现在时序组合器的公式，也叫做当前公式（present formula）。

    这个是一个非常重要而且常见的特殊例子。理论上，它是最简单的案例之一，因为所有的东西都在第6章展示了。

    \paragraph{Safety without past 不包含过去的安全性} 经常会有安全属性是不包含过去的形式。例如，在正式定义中， $\text{\textbf{A}}(\neg\text{\textbf{starts W key}})$（7.1）要比$ \text{\textbf{AG}}(\text{\textbf{starts}}\Rightarrow \text{\textbf{F}}^{-1} \text{ key} )$（7.3）遇到得多。

    选（7.1）还是（7.3）呢？前者看起来对于模型检查器用户来说更自然。这是因为当前没有哪个模型检查器能够解决过去公式，所以几乎所有的时序逻辑表达（特别是所有的实际用途）都依赖于未来逻辑。这里的第2章也不例外。

    然而，使用混合逻辑由两个优点：
    \begin{itemize}
      \item 混合逻辑可以允许以一种保证安全性的语法来写公式$\text{\textbf{AG}}\phi^-$。这样的保证在未来逻辑中是不明显的。从（7.1）和（7.2）的比较中就可以看出只有前者才是安全属性；
      \item 混合逻辑提供了丰富的形式，更加适应倾向于自由混合过去和未来动词的自然语言转换。
    \end{itemize}

    对于不包含过去的安全性公式，第一个问题是它们的确认。一旦确认了，如果我们的模型检查器可以处理时序逻辑，这样的公式可以直接被解决了。否则，我们可以用7.4小节的历史变量方法（history variables method）。

    \paragraph{Safety with explicit past 显性包含过去的安全性} 回想一下，当前（在我们认知中）没有模型检查器可以处理包含过去的时序公式。为了解决形如$\text{\textbf{AG}}\phi^-$的安全属性，由两种可能的解决办法：我们简短介绍的消除过去（eliminating the past）方法，和我们下个小节将的历史变量方法（history variables method）。

    \paragraph{Eliminating the past 消除过去} 理论上，有可能把任意的结合了过去和未来的时序逻辑公式，翻译成等价的纯未来公式[LS95]。注意以下，在公式$\text{\textbf{AG}}\phi^-$的案例中，结果不必要是一个CTL公式。然而这些翻译被证明了是相当脆弱，并且在实际中，低效运行的点依赖于几个简单的模式，例如$\text{\textbf{AG}})(\dots\Rightarrow\text{\textbf{F}}^{-1})\dots$。因为这些等价式子一旦给出了，那么所有的都一样：
    \begin{equation*}
      \text{\textbf{AG}}(\phi\Rightarrow\text{\textbf{F}}^{-1}\psi)\equiv\text{\textbf{A}}(\neg(\phi\text{\textbf{W}}\psi))
    \end{equation*}

    \section{The History Variables Method 历史变量方法}

    在实际中有可能将处理形如$\text{\textbf{AG}}\phi^-$的属性变成处理一个可达性。这是一个相当简单的过程，并且在任意案例中，当我们的工具不能处理时序逻辑时，这是唯一可用的行动方案。因此我们可以看到，依赖于一个可用的工具，一个显性包含过去的公式有它的有点。

    将公式$\text{\textbf{AG}}\phi^-$翻译成可达性的方法取决于历史变量的使用。历史变量的目的时为了在不修改系统（未来）的行为基础上，储存一些（过去）事件的发生与否。然后这样的历史变量可以用可达性公式来表达 $\text{\textbf{AG}}\phi^-$ 。

    \paragraph{An example 一个例子} 可以用一个简单的例子来说明构建过程。思考以下图7.1的自动机$\mathcal{A}$。
    \begin{figure}
        \centering
        \includegraphics[width=3.0in,height=2.0in]{7_1.jpg}
        \caption{$\mathcal{A}$, a model of an alarm}
    \end{figure}

    我们希望验证，每次 alarm（闹钟）响了，都必须有一个 crash 事先发生，用组合器$\text{\textbf{F}}^{-1}$表达为$\text{\textbf{AG}}(\text{\textbf{alarm}}\Rightarrow\text{\textbf{F}}^{-1}\text{\textbf{crash}})$。另外，我们希望验证每次alarm响了，从上次crash之后在没有reset发生过。这两个属性的结合可以用$\text{\textbf{S}}$组合器表达为：$\text{\textbf{AG}}(\text{\textbf{alarm}}\Rightarrow(\neg\text{\textbf{reset}})\text{\textbf{S crash}})$。

    我们还希望验证每次闹钟发出声音之后都有一个crash跟着，用组合器$\text{\textbf{X}}^{-1}$（对应“直接父状态”）表达为$\text{\textbf{AG}}(\text{\textbf{alarm}}\Rightarrow\text{\textbf{X}}^{-1}\text{\textbf{crash}})$。这三个属性都是$\text{\textbf{AG}}\phi^-$的形式，因此都是安全属性。

    通过引进历史变量有可能可以摆脱过去公式$\phi^-$。对于公式$\phi^-$，一个历史变量是一个布尔变量$\text{\textbf{h}}_ {\phi^-}$，其为真当且仅当$\phi^-$为真。因为$\phi^-$是过去公式，它有可能根据每次转换更新历史变量$\text{\textbf{h}}_ {\phi^-}$而不用知道后续的行为是怎样的。

    在上述的例子中，我们需要两个变量：$\text{\textbf{h1}}$对应公式$\text{\textbf{X}}^{-1}\text{\textbf{crash}}$（记为$\phi_1^-$）和$\text{\textbf{h2}}$对应$(\neg\text{\textbf{reset}})\text{\textbf{S crash}}$（记为$\phi_2^-$）。我们会修改图7.1的自动机来包含$\text{\textbf{X}} ^{-1}\text{\textbf{h1}}$和$\text{\textbf{h2}}$，其中两者必须正确表示$\phi_1^-$和$\phi_2^-$的值。

    对于$\text{\textbf{X}} ^{-1}\text{\textbf{crash}}$，更新很简单： $\text{\textbf{h1}}$初始为假。然后从$q$到$q'$的一个转换赋值$\text{\textbf{h1}}$为真当且仅当$q$满足$\text{\textbf{crash}}$，即$q$是$\text{\textbf{crash}}$状态。

    对于$\text{\textbf{h2}}$，策略也是相似的。这里$\phi_2^-$是$(\neg\text{\textbf{reset}})\text{\textbf{S crash}}$。我们设$\text{\textbf{h2}}$初始为假。每一个到达$\text{\textbf{crash}}$状态的转换都会设$\text{\textbf{h2}}$为真。如果其它的转换到达$\text{\textbf{reset}}$状态，它们设$\text{\textbf{h2}}$为假。否则，变量的值不变。这些引出了图7.2的自动机。
    \begin{figure}
        \centering
        \includegraphics[width=5.0in, height=3.0in]{7_2.jpg}
        \caption{$\mathcal{A}_{+\text{hist}}$, the automaton $\mathcal{A}$ enriched with its history variables}
    \end{figure}

    生成的自动机$\mathcal{A}_{+\text{hist}}$有着和$\mathcal{A}$同样的行为（并且它也因此满足同样的时序逻辑公式），但增加两个如下变量：
    \begin{equation*}
      \text{\textbf{AG}}(\text{\textbf{h1}}\Leftrightarrow\text{\textbf{X}}^{-1}\text{\textbf{crash}})\text{ and }\text{\textbf{AG}}(\text{\textbf{h2}}\Leftrightarrow(\neg\text{\textbf{reset}})\text{\textbf{S crash}})
    \end{equation*}
    我们因此将形如“是否$\mathcal{A}\models\text{\textbf{AG}}(\text{\textbf{alarm}}\Rightarrow\text{\textbf{X}} ^{-1}\text{\textbf{crash}})$”的问题变成一个不包含过去的模型检查问题“是否$\mathcal{A}_{+\text{hist}}\models\text{\textbf{AG}}(\text{\textbf{alarm}}\Rightarrow\text{\textbf{h1}})$”。这可以被像SMV的工具处理。

    \paragraph{The general case 普遍的情况} 上述建议的构建过程可以推广起来。它可以为每一个根是过去组合器的子公式引入历史变量。思考一个例子，对于公式$\text{\textbf{F}}^{-1}((\text{\textbf{X}}^{-1}P)\text{\textbf{S}}Q)$，
    我们引入$\text{\textbf{h1}}$对应$\text{\textbf{X}}^{-1}P$，然后$\text{\textbf{h2}}$对应$\text{\textbf{h1 S }}Q$，接着$\text{\textbf{h3}}$对应$\text{\textbf{F}}^{-1}\text{\textbf{h2}}$。这三个变量初始为假并且用图7。2所讲的技术来更新。记住$\text{\textbf{F}}^{-1}$是$\text{\textbf{S}}$的一个特殊情况并且$\text{\textbf{G}}^{-1}$对偶于$\text{\textbf{F}}^{-1}$。

    注意一下，历史变量方法总是会导致（否定）可达性问题。因此，这个技术证明了当我们的工具只能处理可达性的时候，这个方法有利于检查不包含过去的安全性公式。

    更一般地说，历史变量方法可以看作是一种特殊（并且简化）的观察自动机的方法。通过和第二个方法进行比较，实际中的历史变量方法的巨大优势在于，需要的修改步骤不仅容易理解而且容易判断。

    \paragraph{Complexity 复杂度} 因为每一个布尔变量的引入都会使得未展开的自动机状态数量翻倍。如果过去公式的大小不限制，历史变量方法会导致组合爆炸。相应地，拥有丰富的过去组合器的CTL模型检查技术是PSPACE-complete。（PSPACE-完备？）。
\end{document} 